{
  "ast": null,
  "code": "var __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n};\n/**\n* @license Angular v9.1.0-next.4+61.sha-e552591.with-local-changes\n* (c) 2010-2020 Google LLC. https://angular.io/\n* License: MIT\n*/\n\n\n(function (factory) {\n  typeof define === 'function' && define.amd ? define(factory) : factory();\n})(function () {\n  'use strict';\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  /**\n   * @fileoverview\n   * @suppress {globalThis}\n   */\n\n  var NEWLINE = '\\n';\n  var IGNORE_FRAMES = {};\n  var creationTrace = '__creationTrace__';\n  var ERROR_TAG = 'STACKTRACE TRACKING';\n  var SEP_TAG = '__SEP_TAG__';\n  var sepTemplate = SEP_TAG + '@[native]';\n\n  var LongStackTrace =\n  /** @class */\n  function () {\n    function LongStackTrace() {\n      this.error = getStacktrace();\n      this.timestamp = new Date();\n    }\n\n    return LongStackTrace;\n  }();\n\n  function getStacktraceWithUncaughtError() {\n    return new Error(ERROR_TAG);\n  }\n\n  function getStacktraceWithCaughtError() {\n    try {\n      throw getStacktraceWithUncaughtError();\n    } catch (err) {\n      return err;\n    }\n  } // Some implementations of exception handling don't create a stack trace if the exception\n  // isn't thrown, however it's faster not to actually throw the exception.\n\n\n  var error = getStacktraceWithUncaughtError();\n  var caughtError = getStacktraceWithCaughtError();\n  var getStacktrace = error.stack ? getStacktraceWithUncaughtError : caughtError.stack ? getStacktraceWithCaughtError : getStacktraceWithUncaughtError;\n\n  function getFrames(error) {\n    return error.stack ? error.stack.split(NEWLINE) : [];\n  }\n\n  function addErrorStack(lines, error) {\n    var trace = getFrames(error);\n\n    for (var i = 0; i < trace.length; i++) {\n      var frame = trace[i]; // Filter out the Frames which are part of stack capturing.\n\n      if (!IGNORE_FRAMES.hasOwnProperty(frame)) {\n        lines.push(trace[i]);\n      }\n    }\n  }\n\n  function renderLongStackTrace(frames, stack) {\n    var longTrace = [stack ? stack.trim() : ''];\n\n    if (frames) {\n      var timestamp = new Date().getTime();\n\n      for (var i = 0; i < frames.length; i++) {\n        var traceFrames = frames[i];\n        var lastTime = traceFrames.timestamp;\n        var separator = \"____________________Elapsed \" + (timestamp - lastTime.getTime()) + \" ms; At: \" + lastTime;\n        separator = separator.replace(/[^\\w\\d]/g, '_');\n        longTrace.push(sepTemplate.replace(SEP_TAG, separator));\n        addErrorStack(longTrace, traceFrames.error);\n        timestamp = lastTime.getTime();\n      }\n    }\n\n    return longTrace.join(NEWLINE);\n  } // if Error.stackTraceLimit is 0, means stack trace\n  // is disabled, so we don't need to generate long stack trace\n  // this will improve performance in some test(some test will\n  // set stackTraceLimit to 0, https://github.com/angular/zone.js/issues/698\n\n\n  function stackTracesEnabled() {\n    // Cast through any since this property only exists on Error in the nodejs\n    // typings.\n    return Error.stackTraceLimit > 0;\n  }\n\n  Zone['longStackTraceZoneSpec'] = {\n    name: 'long-stack-trace',\n    longStackTraceLimit: 10,\n    // add a getLongStackTrace method in spec to\n    // handle handled reject promise error.\n    getLongStackTrace: function getLongStackTrace(error) {\n      if (!error) {\n        return undefined;\n      }\n\n      var trace = error[Zone.__symbol__('currentTaskTrace')];\n\n      if (!trace) {\n        return error.stack;\n      }\n\n      return renderLongStackTrace(trace, error.stack);\n    },\n    onScheduleTask: function onScheduleTask(parentZoneDelegate, currentZone, targetZone, task) {\n      if (stackTracesEnabled()) {\n        var currentTask = Zone.currentTask;\n        var trace = currentTask && currentTask.data && currentTask.data[creationTrace] || [];\n        trace = [new LongStackTrace()].concat(trace);\n\n        if (trace.length > this.longStackTraceLimit) {\n          trace.length = this.longStackTraceLimit;\n        }\n\n        if (!task.data) task.data = {};\n\n        if (task.type === 'eventTask') {\n          // Fix issue https://github.com/angular/zone.js/issues/1195,\n          // For event task of browser, by default, all task will share a\n          // singleton instance of data object, we should create a new one here\n          // The cast to `any` is required to workaround a closure bug which wrongly applies\n          // URL sanitization rules to .data access.\n          task.data = Object.assign({}, task.data);\n        }\n\n        task.data[creationTrace] = trace;\n      }\n\n      return parentZoneDelegate.scheduleTask(targetZone, task);\n    },\n    onHandleError: function onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n      if (stackTracesEnabled()) {\n        var parentTask = Zone.currentTask || error.task;\n\n        if (error instanceof Error && parentTask) {\n          var longStack = renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error.stack);\n\n          try {\n            error.stack = error.longStack = longStack;\n          } catch (err) {}\n        }\n      }\n\n      return parentZoneDelegate.handleError(targetZone, error);\n    }\n  };\n\n  function captureStackTraces(stackTraces, count) {\n    if (count > 0) {\n      stackTraces.push(getFrames(new LongStackTrace().error));\n      captureStackTraces(stackTraces, count - 1);\n    }\n  }\n\n  function computeIgnoreFrames() {\n    if (!stackTracesEnabled()) {\n      return;\n    }\n\n    var frames = [];\n    captureStackTraces(frames, 2);\n    var frames1 = frames[0];\n    var frames2 = frames[1];\n\n    for (var i = 0; i < frames1.length; i++) {\n      var frame1 = frames1[i];\n\n      if (frame1.indexOf(ERROR_TAG) == -1) {\n        var match = frame1.match(/^\\s*at\\s+/);\n\n        if (match) {\n          sepTemplate = match[0] + SEP_TAG + ' (http://localhost)';\n          break;\n        }\n      }\n    }\n\n    for (var i = 0; i < frames1.length; i++) {\n      var frame1 = frames1[i];\n      var frame2 = frames2[i];\n\n      if (frame1 === frame2) {\n        IGNORE_FRAMES[frame1] = true;\n      } else {\n        break;\n      }\n    }\n  }\n\n  computeIgnoreFrames();\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  var ProxyZoneSpec =\n  /** @class */\n  function () {\n    function ProxyZoneSpec(defaultSpecDelegate) {\n      if (defaultSpecDelegate === void 0) {\n        defaultSpecDelegate = null;\n      }\n\n      this.defaultSpecDelegate = defaultSpecDelegate;\n      this.name = 'ProxyZone';\n      this._delegateSpec = null;\n      this.properties = {\n        'ProxyZoneSpec': this\n      };\n      this.propertyKeys = null;\n      this.lastTaskState = null;\n      this.isNeedToTriggerHasTask = false;\n      this.tasks = [];\n      this.setDelegate(defaultSpecDelegate);\n    }\n\n    ProxyZoneSpec.get = function () {\n      return Zone.current.get('ProxyZoneSpec');\n    };\n\n    ProxyZoneSpec.isLoaded = function () {\n      return ProxyZoneSpec.get() instanceof ProxyZoneSpec;\n    };\n\n    ProxyZoneSpec.assertPresent = function () {\n      if (!ProxyZoneSpec.isLoaded()) {\n        throw new Error(\"Expected to be running in 'ProxyZone', but it was not found.\");\n      }\n\n      return ProxyZoneSpec.get();\n    };\n\n    ProxyZoneSpec.prototype.setDelegate = function (delegateSpec) {\n      var _this = this;\n\n      var isNewDelegate = this._delegateSpec !== delegateSpec;\n      this._delegateSpec = delegateSpec;\n      this.propertyKeys && this.propertyKeys.forEach(function (key) {\n        return delete _this.properties[key];\n      });\n      this.propertyKeys = null;\n\n      if (delegateSpec && delegateSpec.properties) {\n        this.propertyKeys = Object.keys(delegateSpec.properties);\n        this.propertyKeys.forEach(function (k) {\n          return _this.properties[k] = delegateSpec.properties[k];\n        });\n      } // if a new delegateSpec was set, check if we need to trigger hasTask\n\n\n      if (isNewDelegate && this.lastTaskState && (this.lastTaskState.macroTask || this.lastTaskState.microTask)) {\n        this.isNeedToTriggerHasTask = true;\n      }\n    };\n\n    ProxyZoneSpec.prototype.getDelegate = function () {\n      return this._delegateSpec;\n    };\n\n    ProxyZoneSpec.prototype.resetDelegate = function () {\n      var delegateSpec = this.getDelegate();\n      this.setDelegate(this.defaultSpecDelegate);\n    };\n\n    ProxyZoneSpec.prototype.tryTriggerHasTask = function (parentZoneDelegate, currentZone, targetZone) {\n      if (this.isNeedToTriggerHasTask && this.lastTaskState) {\n        // last delegateSpec has microTask or macroTask\n        // should call onHasTask in current delegateSpec\n        this.isNeedToTriggerHasTask = false;\n        this.onHasTask(parentZoneDelegate, currentZone, targetZone, this.lastTaskState);\n      }\n    };\n\n    ProxyZoneSpec.prototype.removeFromTasks = function (task) {\n      if (!this.tasks) {\n        return;\n      }\n\n      for (var i = 0; i < this.tasks.length; i++) {\n        if (this.tasks[i] === task) {\n          this.tasks.splice(i, 1);\n          return;\n        }\n      }\n    };\n\n    ProxyZoneSpec.prototype.getAndClearPendingTasksInfo = function () {\n      if (this.tasks.length === 0) {\n        return '';\n      }\n\n      var taskInfo = this.tasks.map(function (task) {\n        var dataInfo = task.data && Object.keys(task.data).map(function (key) {\n          return key + ':' + task.data[key];\n        }).join(',');\n        return \"type: \" + task.type + \", source: \" + task.source + \", args: {\" + dataInfo + \"}\";\n      });\n      var pendingTasksInfo = '--Pending async tasks are: [' + taskInfo + ']'; // clear tasks\n\n      this.tasks = [];\n      return pendingTasksInfo;\n    };\n\n    ProxyZoneSpec.prototype.onFork = function (parentZoneDelegate, currentZone, targetZone, zoneSpec) {\n      if (this._delegateSpec && this._delegateSpec.onFork) {\n        return this._delegateSpec.onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec);\n      } else {\n        return parentZoneDelegate.fork(targetZone, zoneSpec);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onIntercept = function (parentZoneDelegate, currentZone, targetZone, delegate, source) {\n      if (this._delegateSpec && this._delegateSpec.onIntercept) {\n        return this._delegateSpec.onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source);\n      } else {\n        return parentZoneDelegate.intercept(targetZone, delegate, source);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onInvoke = function (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n      this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n\n      if (this._delegateSpec && this._delegateSpec.onInvoke) {\n        return this._delegateSpec.onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source);\n      } else {\n        return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n      if (this._delegateSpec && this._delegateSpec.onHandleError) {\n        return this._delegateSpec.onHandleError(parentZoneDelegate, currentZone, targetZone, error);\n      } else {\n        return parentZoneDelegate.handleError(targetZone, error);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onScheduleTask = function (parentZoneDelegate, currentZone, targetZone, task) {\n      if (task.type !== 'eventTask') {\n        this.tasks.push(task);\n      }\n\n      if (this._delegateSpec && this._delegateSpec.onScheduleTask) {\n        return this._delegateSpec.onScheduleTask(parentZoneDelegate, currentZone, targetZone, task);\n      } else {\n        return parentZoneDelegate.scheduleTask(targetZone, task);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onInvokeTask = function (parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) {\n      if (task.type !== 'eventTask') {\n        this.removeFromTasks(task);\n      }\n\n      this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n\n      if (this._delegateSpec && this._delegateSpec.onInvokeTask) {\n        return this._delegateSpec.onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs);\n      } else {\n        return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onCancelTask = function (parentZoneDelegate, currentZone, targetZone, task) {\n      if (task.type !== 'eventTask') {\n        this.removeFromTasks(task);\n      }\n\n      this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n\n      if (this._delegateSpec && this._delegateSpec.onCancelTask) {\n        return this._delegateSpec.onCancelTask(parentZoneDelegate, currentZone, targetZone, task);\n      } else {\n        return parentZoneDelegate.cancelTask(targetZone, task);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onHasTask = function (delegate, current, target, hasTaskState) {\n      this.lastTaskState = hasTaskState;\n\n      if (this._delegateSpec && this._delegateSpec.onHasTask) {\n        this._delegateSpec.onHasTask(delegate, current, target, hasTaskState);\n      } else {\n        delegate.hasTask(target, hasTaskState);\n      }\n    };\n\n    return ProxyZoneSpec;\n  }(); // Export the class so that new instances can be created with proper\n  // constructor params.\n\n\n  Zone['ProxyZoneSpec'] = ProxyZoneSpec;\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  var SyncTestZoneSpec =\n  /** @class */\n  function () {\n    function SyncTestZoneSpec(namePrefix) {\n      this.runZone = Zone.current;\n      this.name = 'syncTestZone for ' + namePrefix;\n    }\n\n    SyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n      switch (task.type) {\n        case 'microTask':\n        case 'macroTask':\n          throw new Error(\"Cannot call \" + task.source + \" from within a sync test.\");\n\n        case 'eventTask':\n          task = delegate.scheduleTask(target, task);\n          break;\n      }\n\n      return task;\n    };\n\n    return SyncTestZoneSpec;\n  }(); // Export the class so that new instances can be created with proper\n  // constructor params.\n\n\n  Zone['SyncTestZoneSpec'] = SyncTestZoneSpec;\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  Zone.__load_patch('jasmine', function (global, Zone, api) {\n    var __extends = function __extends(d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n\n      function __() {\n        this.constructor = d;\n      }\n\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    }; // Patch jasmine's describe/it/beforeEach/afterEach functions so test code always runs\n    // in a testZone (ProxyZone). (See: angular/zone.js#91 & angular/angular#10503)\n\n\n    if (!Zone) throw new Error('Missing: zone.js');\n\n    if (typeof jest !== 'undefined') {\n      // return if jasmine is a light implementation inside jest\n      // in this case, we are running inside jest not jasmine\n      return;\n    }\n\n    if (typeof jasmine == 'undefined' || jasmine['__zone_patch__']) {\n      return;\n    }\n\n    jasmine['__zone_patch__'] = true;\n    var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n    var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    if (!SyncTestZoneSpec) throw new Error('Missing: SyncTestZoneSpec');\n    if (!ProxyZoneSpec) throw new Error('Missing: ProxyZoneSpec');\n    var ambientZone = Zone.current; // Create a synchronous-only zone in which to run `describe` blocks in order to raise an\n    // error if any asynchronous operations are attempted inside of a `describe` but outside of\n    // a `beforeEach` or `it`.\n\n    var syncZone = ambientZone.fork(new SyncTestZoneSpec('jasmine.describe'));\n    var symbol = Zone.__symbol__; // whether patch jasmine clock when in fakeAsync\n\n    var disablePatchingJasmineClock = global[symbol('fakeAsyncDisablePatchingClock')] === true; // the original variable name fakeAsyncPatchLock is not accurate, so the name will be\n    // fakeAsyncAutoFakeAsyncWhenClockPatched and if this enablePatchingJasmineClock is false, we also\n    // automatically disable the auto jump into fakeAsync feature\n\n    var enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock && (global[symbol('fakeAsyncPatchLock')] === true || global[symbol('fakeAsyncAutoFakeAsyncWhenClockPatched')] === true);\n    var ignoreUnhandledRejection = global[symbol('ignoreUnhandledRejection')] === true;\n\n    if (!ignoreUnhandledRejection) {\n      var globalErrors_1 = jasmine.GlobalErrors;\n\n      if (globalErrors_1 && !jasmine[symbol('GlobalErrors')]) {\n        jasmine[symbol('GlobalErrors')] = globalErrors_1;\n\n        jasmine.GlobalErrors = function () {\n          var instance = new globalErrors_1();\n          var originalInstall = instance.install;\n\n          if (originalInstall && !instance[symbol('install')]) {\n            instance[symbol('install')] = originalInstall;\n\n            instance.install = function () {\n              var originalHandlers = process.listeners('unhandledRejection');\n              var r = originalInstall.apply(this, arguments);\n              process.removeAllListeners('unhandledRejection');\n\n              if (originalHandlers) {\n                originalHandlers.forEach(function (h) {\n                  return process.on('unhandledRejection', h);\n                });\n              }\n\n              return r;\n            };\n          }\n\n          return instance;\n        };\n      }\n    } // Monkey patch all of the jasmine DSL so that each function runs in appropriate zone.\n\n\n    var jasmineEnv = jasmine.getEnv();\n    ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n      var originalJasmineFn = jasmineEnv[methodName];\n\n      jasmineEnv[methodName] = function (description, specDefinitions) {\n        return originalJasmineFn.call(this, description, wrapDescribeInZone(specDefinitions));\n      };\n    });\n    ['it', 'xit', 'fit'].forEach(function (methodName) {\n      var originalJasmineFn = jasmineEnv[methodName];\n      jasmineEnv[symbol(methodName)] = originalJasmineFn;\n\n      jasmineEnv[methodName] = function (description, specDefinitions, timeout) {\n        arguments[1] = wrapTestInZone(specDefinitions);\n        return originalJasmineFn.apply(this, arguments);\n      };\n    });\n    ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n      var originalJasmineFn = jasmineEnv[methodName];\n      jasmineEnv[symbol(methodName)] = originalJasmineFn;\n\n      jasmineEnv[methodName] = function (specDefinitions, timeout) {\n        arguments[0] = wrapTestInZone(specDefinitions);\n        return originalJasmineFn.apply(this, arguments);\n      };\n    });\n\n    if (!disablePatchingJasmineClock) {\n      // need to patch jasmine.clock().mockDate and jasmine.clock().tick() so\n      // they can work properly in FakeAsyncTest\n      var originalClockFn_1 = jasmine[symbol('clock')] = jasmine['clock'];\n\n      jasmine['clock'] = function () {\n        var clock = originalClockFn_1.apply(this, arguments);\n\n        if (!clock[symbol('patched')]) {\n          clock[symbol('patched')] = symbol('patched');\n          var originalTick_1 = clock[symbol('tick')] = clock.tick;\n\n          clock.tick = function () {\n            var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n            if (fakeAsyncZoneSpec) {\n              return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);\n            }\n\n            return originalTick_1.apply(this, arguments);\n          };\n\n          var originalMockDate_1 = clock[symbol('mockDate')] = clock.mockDate;\n\n          clock.mockDate = function () {\n            var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n            if (fakeAsyncZoneSpec) {\n              var dateTime = arguments.length > 0 ? arguments[0] : new Date();\n              return fakeAsyncZoneSpec.setCurrentRealTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === 'function' ? [dateTime.getTime()] : arguments);\n            }\n\n            return originalMockDate_1.apply(this, arguments);\n          }; // for auto go into fakeAsync feature, we need the flag to enable it\n\n\n          if (enableAutoFakeAsyncWhenClockPatched) {\n            ['install', 'uninstall'].forEach(function (methodName) {\n              var originalClockFn = clock[symbol(methodName)] = clock[methodName];\n\n              clock[methodName] = function () {\n                var FakeAsyncTestZoneSpec = Zone['FakeAsyncTestZoneSpec'];\n\n                if (FakeAsyncTestZoneSpec) {\n                  jasmine[symbol('clockInstalled')] = 'install' === methodName;\n                  return;\n                }\n\n                return originalClockFn.apply(this, arguments);\n              };\n            });\n          }\n        }\n\n        return clock;\n      };\n    }\n    /**\n     * Gets a function wrapping the body of a Jasmine `describe` block to execute in a\n     * synchronous-only zone.\n     */\n\n\n    function wrapDescribeInZone(describeBody) {\n      return function () {\n        return syncZone.run(describeBody, this, arguments);\n      };\n    }\n\n    function runInTestZone(testBody, applyThis, queueRunner, done) {\n      var isClockInstalled = !!jasmine[symbol('clockInstalled')];\n      var testProxyZoneSpec = queueRunner.testProxyZoneSpec;\n      var testProxyZone = queueRunner.testProxyZone;\n\n      if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {\n        // auto run a fakeAsync\n        var fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n\n        if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n          testBody = fakeAsyncModule.fakeAsync(testBody);\n        }\n      }\n\n      if (done) {\n        return testProxyZone.run(testBody, applyThis, [done]);\n      } else {\n        return testProxyZone.run(testBody, applyThis);\n      }\n    }\n    /**\n     * Gets a function wrapping the body of a Jasmine `it/beforeEach/afterEach` block to\n     * execute in a ProxyZone zone.\n     * This will run in `testProxyZone`. The `testProxyZone` will be reset by the `ZoneQueueRunner`\n     */\n\n\n    function wrapTestInZone(testBody) {\n      // The `done` callback is only passed through if the function expects at least one argument.\n      // Note we have to make a function with correct number of arguments, otherwise jasmine will\n      // think that all functions are sync or async.\n      return testBody && (testBody.length ? function (done) {\n        return runInTestZone(testBody, this, this.queueRunner, done);\n      } : function () {\n        return runInTestZone(testBody, this, this.queueRunner);\n      });\n    }\n\n    var QueueRunner = jasmine.QueueRunner;\n\n    jasmine.QueueRunner = function (_super) {\n      __extends(ZoneQueueRunner, _super);\n\n      function ZoneQueueRunner(attrs) {\n        var _this = this;\n\n        if (attrs.onComplete) {\n          attrs.onComplete = function (fn) {\n            return function () {\n              // All functions are done, clear the test zone.\n              _this.testProxyZone = null;\n              _this.testProxyZoneSpec = null;\n              ambientZone.scheduleMicroTask('jasmine.onComplete', fn);\n            };\n          }(attrs.onComplete);\n        }\n\n        var nativeSetTimeout = global[Zone.__symbol__('setTimeout')];\n\n        var nativeClearTimeout = global[Zone.__symbol__('clearTimeout')];\n\n        if (nativeSetTimeout) {\n          // should run setTimeout inside jasmine outside of zone\n          attrs.timeout = {\n            setTimeout: nativeSetTimeout ? nativeSetTimeout : global.setTimeout,\n            clearTimeout: nativeClearTimeout ? nativeClearTimeout : global.clearTimeout\n          };\n        } // create a userContext to hold the queueRunner itself\n        // so we can access the testProxy in it/xit/beforeEach ...\n\n\n        if (jasmine.UserContext) {\n          if (!attrs.userContext) {\n            attrs.userContext = new jasmine.UserContext();\n          }\n\n          attrs.userContext.queueRunner = this;\n        } else {\n          if (!attrs.userContext) {\n            attrs.userContext = {};\n          }\n\n          attrs.userContext.queueRunner = this;\n        } // patch attrs.onException\n\n\n        var onException = attrs.onException;\n\n        attrs.onException = function (error) {\n          if (error && error.message === 'Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.') {\n            // jasmine timeout, we can make the error message more\n            // reasonable to tell what tasks are pending\n            var proxyZoneSpec = this && this.testProxyZoneSpec;\n\n            if (proxyZoneSpec) {\n              var pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();\n\n              try {\n                // try catch here in case error.message is not writable\n                error.message += pendingTasksInfo;\n              } catch (err) {}\n            }\n          }\n\n          if (onException) {\n            onException.call(this, error);\n          }\n        };\n\n        _super.call(this, attrs);\n      }\n\n      ZoneQueueRunner.prototype.execute = function () {\n        var _this = this;\n\n        var zone = Zone.current;\n        var isChildOfAmbientZone = false;\n\n        while (zone) {\n          if (zone === ambientZone) {\n            isChildOfAmbientZone = true;\n            break;\n          }\n\n          zone = zone.parent;\n        }\n\n        if (!isChildOfAmbientZone) throw new Error('Unexpected Zone: ' + Zone.current.name); // This is the zone which will be used for running individual tests.\n        // It will be a proxy zone, so that the tests function can retroactively install\n        // different zones.\n        // Example:\n        //   - In beforeEach() do childZone = Zone.current.fork(...);\n        //   - In it() try to do fakeAsync(). The issue is that because the beforeEach forked the\n        //     zone outside of fakeAsync it will be able to escape the fakeAsync rules.\n        //   - Because ProxyZone is parent fo `childZone` fakeAsync can retroactively add\n        //     fakeAsync behavior to the childZone.\n\n        this.testProxyZoneSpec = new ProxyZoneSpec();\n        this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);\n\n        if (!Zone.currentTask) {\n          // if we are not running in a task then if someone would register a\n          // element.addEventListener and then calling element.click() the\n          // addEventListener callback would think that it is the top most task and would\n          // drain the microtask queue on element.click() which would be incorrect.\n          // For this reason we always force a task when running jasmine tests.\n          Zone.current.scheduleMicroTask('jasmine.execute().forceTask', function () {\n            return QueueRunner.prototype.execute.call(_this);\n          });\n        } else {\n          _super.prototype.execute.call(this);\n        }\n      };\n\n      return ZoneQueueRunner;\n    }(QueueRunner);\n  });\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  Zone.__load_patch('jest', function (context, Zone) {\n    if (typeof jest === 'undefined' || jest['__zone_patch__']) {\n      return;\n    }\n\n    jest['__zone_patch__'] = true;\n\n    if (typeof Zone === 'undefined') {\n      throw new Error('Missing Zone.js');\n    }\n\n    var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n\n    if (!ProxyZoneSpec) {\n      throw new Error('Missing ProxyZoneSpec');\n    }\n\n    var rootZone = Zone.current;\n    var syncZone = rootZone.fork(new SyncTestZoneSpec('jest.describe'));\n    var proxyZone = rootZone.fork(new ProxyZoneSpec());\n\n    function wrapDescribeFactoryInZone(originalJestFn) {\n      return function () {\n        var tableArgs = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          tableArgs[_i] = arguments[_i];\n        }\n\n        var originalDescribeFn = originalJestFn.apply(this, tableArgs);\n        return function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          args[1] = wrapDescribeInZone(args[1]);\n          return originalDescribeFn.apply(this, args);\n        };\n      };\n    }\n\n    function wrapTestFactoryInZone(originalJestFn) {\n      return function () {\n        var tableArgs = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          tableArgs[_i] = arguments[_i];\n        }\n\n        var testFn = originalJestFn.apply(this, tableArgs);\n        return function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          args[1] = wrapTestInZone(args[1]);\n          return testFn.apply(this, args);\n        };\n      };\n    }\n    /**\n     * Gets a function wrapping the body of a jest `describe` block to execute in a\n     * synchronous-only zone.\n     */\n\n\n    function wrapDescribeInZone(describeBody) {\n      return function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        return syncZone.run(describeBody, this, args);\n      };\n    }\n    /**\n     * Gets a function wrapping the body of a jest `it/beforeEach/afterEach` block to\n     * execute in a ProxyZone zone.\n     * This will run in the `testProxyZone`.\n     */\n\n\n    function wrapTestInZone(testBody) {\n      if (typeof testBody !== 'function') {\n        return testBody;\n      } // The `done` callback is only passed through if the function expects at least one argument.\n      // Note we have to make a function with correct number of arguments, otherwise jest will\n      // think that all functions are sync or async.\n\n\n      return function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        return proxyZone.run(testBody, this, args);\n      };\n    }\n\n    ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n      var originalJestFn = context[methodName];\n\n      if (context[Zone.__symbol__(methodName)]) {\n        return;\n      }\n\n      context[Zone.__symbol__(methodName)] = originalJestFn;\n\n      context[methodName] = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        args[1] = wrapDescribeInZone(args[1]);\n        return originalJestFn.apply(this, args);\n      };\n\n      context[methodName].each = wrapDescribeFactoryInZone(originalJestFn.each);\n    });\n    context.describe.only = context.fdescribe;\n    context.describe.skip = context.xdescribe;\n    ['it', 'xit', 'fit', 'test', 'xtest'].forEach(function (methodName) {\n      var originalJestFn = context[methodName];\n\n      if (context[Zone.__symbol__(methodName)]) {\n        return;\n      }\n\n      context[Zone.__symbol__(methodName)] = originalJestFn;\n\n      context[methodName] = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        args[1] = wrapTestInZone(args[1]);\n        return originalJestFn.apply(this, args);\n      };\n\n      context[methodName].each = wrapTestFactoryInZone(originalJestFn.each);\n      context[methodName].todo = originalJestFn.todo;\n    });\n    context.it.only = context.fit;\n    context.it.skip = context.xit;\n    context.test.only = context.fit;\n    context.test.skip = context.xit;\n    ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n      var originalJestFn = context[methodName];\n\n      if (context[Zone.__symbol__(methodName)]) {\n        return;\n      }\n\n      context[Zone.__symbol__(methodName)] = originalJestFn;\n\n      context[methodName] = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        args[0] = wrapTestInZone(args[0]);\n        return originalJestFn.apply(this, args);\n      };\n    });\n  });\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  Zone.__load_patch('mocha', function (global, Zone) {\n    var Mocha = global.Mocha;\n\n    if (typeof Mocha === 'undefined') {\n      // return if Mocha is not available, because now zone-testing\n      // will load mocha patch with jasmine/jest patch\n      return;\n    }\n\n    if (typeof Zone === 'undefined') {\n      throw new Error('Missing Zone.js');\n    }\n\n    var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n\n    if (!ProxyZoneSpec) {\n      throw new Error('Missing ProxyZoneSpec');\n    }\n\n    if (Mocha['__zone_patch__']) {\n      throw new Error('\"Mocha\" has already been patched with \"Zone\".');\n    }\n\n    Mocha['__zone_patch__'] = true;\n    var rootZone = Zone.current;\n    var syncZone = rootZone.fork(new SyncTestZoneSpec('Mocha.describe'));\n    var testZone = null;\n    var suiteZone = rootZone.fork(new ProxyZoneSpec());\n    var mochaOriginal = {\n      after: Mocha.after,\n      afterEach: Mocha.afterEach,\n      before: Mocha.before,\n      beforeEach: Mocha.beforeEach,\n      describe: Mocha.describe,\n      it: Mocha.it\n    };\n\n    function modifyArguments(args, syncTest, asyncTest) {\n      var _loop_1 = function _loop_1(i) {\n        var arg = args[i];\n\n        if (typeof arg === 'function') {\n          // The `done` callback is only passed through if the function expects at\n          // least one argument.\n          // Note we have to make a function with correct number of arguments,\n          // otherwise mocha will\n          // think that all functions are sync or async.\n          args[i] = arg.length === 0 ? syncTest(arg) : asyncTest(arg); // Mocha uses toString to view the test body in the result list, make sure we return the\n          // correct function body\n\n          args[i].toString = function () {\n            return arg.toString();\n          };\n        }\n      };\n\n      for (var i = 0; i < args.length; i++) {\n        _loop_1(i);\n      }\n\n      return args;\n    }\n\n    function wrapDescribeInZone(args) {\n      var syncTest = function syncTest(fn) {\n        return function () {\n          return syncZone.run(fn, this, arguments);\n        };\n      };\n\n      return modifyArguments(args, syncTest);\n    }\n\n    function wrapTestInZone(args) {\n      var asyncTest = function asyncTest(fn) {\n        return function (done) {\n          return testZone.run(fn, this, [done]);\n        };\n      };\n\n      var syncTest = function syncTest(fn) {\n        return function () {\n          return testZone.run(fn, this);\n        };\n      };\n\n      return modifyArguments(args, syncTest, asyncTest);\n    }\n\n    function wrapSuiteInZone(args) {\n      var asyncTest = function asyncTest(fn) {\n        return function (done) {\n          return suiteZone.run(fn, this, [done]);\n        };\n      };\n\n      var syncTest = function syncTest(fn) {\n        return function () {\n          return suiteZone.run(fn, this);\n        };\n      };\n\n      return modifyArguments(args, syncTest, asyncTest);\n    }\n\n    global.describe = global.suite = Mocha.describe = function () {\n      return mochaOriginal.describe.apply(this, wrapDescribeInZone(arguments));\n    };\n\n    global.xdescribe = global.suite.skip = Mocha.describe.skip = function () {\n      return mochaOriginal.describe.skip.apply(this, wrapDescribeInZone(arguments));\n    };\n\n    global.describe.only = global.suite.only = Mocha.describe.only = function () {\n      return mochaOriginal.describe.only.apply(this, wrapDescribeInZone(arguments));\n    };\n\n    global.it = global.specify = global.test = Mocha.it = function () {\n      return mochaOriginal.it.apply(this, wrapTestInZone(arguments));\n    };\n\n    global.xit = global.xspecify = Mocha.it.skip = function () {\n      return mochaOriginal.it.skip.apply(this, wrapTestInZone(arguments));\n    };\n\n    global.it.only = global.test.only = Mocha.it.only = function () {\n      return mochaOriginal.it.only.apply(this, wrapTestInZone(arguments));\n    };\n\n    global.after = global.suiteTeardown = Mocha.after = function () {\n      return mochaOriginal.after.apply(this, wrapSuiteInZone(arguments));\n    };\n\n    global.afterEach = global.teardown = Mocha.afterEach = function () {\n      return mochaOriginal.afterEach.apply(this, wrapTestInZone(arguments));\n    };\n\n    global.before = global.suiteSetup = Mocha.before = function () {\n      return mochaOriginal.before.apply(this, wrapSuiteInZone(arguments));\n    };\n\n    global.beforeEach = global.setup = Mocha.beforeEach = function () {\n      return mochaOriginal.beforeEach.apply(this, wrapTestInZone(arguments));\n    };\n\n    (function (originalRunTest, originalRun) {\n      Mocha.Runner.prototype.runTest = function (fn) {\n        var _this = this;\n\n        Zone.current.scheduleMicroTask('mocha.forceTask', function () {\n          originalRunTest.call(_this, fn);\n        });\n      };\n\n      Mocha.Runner.prototype.run = function (fn) {\n        this.on('test', function (e) {\n          testZone = rootZone.fork(new ProxyZoneSpec());\n        });\n        this.on('fail', function (test, err) {\n          var proxyZoneSpec = testZone && testZone.get('ProxyZoneSpec');\n\n          if (proxyZoneSpec && err) {\n            try {\n              // try catch here in case err.message is not writable\n              err.message += proxyZoneSpec.getAndClearPendingTasksInfo();\n            } catch (error) {}\n          }\n        });\n        return originalRun.call(this, fn);\n      };\n    })(Mocha.Runner.prototype.runTest, Mocha.Runner.prototype.run);\n  });\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  (function (_global) {\n    var AsyncTestZoneSpec =\n    /** @class */\n    function () {\n      function AsyncTestZoneSpec(finishCallback, failCallback, namePrefix) {\n        this.finishCallback = finishCallback;\n        this.failCallback = failCallback;\n        this._pendingMicroTasks = false;\n        this._pendingMacroTasks = false;\n        this._alreadyErrored = false;\n        this._isSync = false;\n        this.runZone = Zone.current;\n        this.unresolvedChainedPromiseCount = 0;\n        this.supportWaitUnresolvedChainedPromise = false;\n        this.name = 'asyncTestZone for ' + namePrefix;\n        this.properties = {\n          'AsyncTestZoneSpec': this\n        };\n        this.supportWaitUnresolvedChainedPromise = _global[Zone.__symbol__('supportWaitUnResolvedChainedPromise')] === true;\n      }\n\n      AsyncTestZoneSpec.prototype.isUnresolvedChainedPromisePending = function () {\n        return this.unresolvedChainedPromiseCount > 0;\n      };\n\n      AsyncTestZoneSpec.prototype._finishCallbackIfDone = function () {\n        var _this = this;\n\n        if (!(this._pendingMicroTasks || this._pendingMacroTasks || this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending())) {\n          // We do this because we would like to catch unhandled rejected promises.\n          this.runZone.run(function () {\n            setTimeout(function () {\n              if (!_this._alreadyErrored && !(_this._pendingMicroTasks || _this._pendingMacroTasks)) {\n                _this.finishCallback();\n              }\n            }, 0);\n          });\n        }\n      };\n\n      AsyncTestZoneSpec.prototype.patchPromiseForTest = function () {\n        if (!this.supportWaitUnresolvedChainedPromise) {\n          return;\n        }\n\n        var patchPromiseForTest = Promise[Zone.__symbol__('patchPromiseForTest')];\n\n        if (patchPromiseForTest) {\n          patchPromiseForTest();\n        }\n      };\n\n      AsyncTestZoneSpec.prototype.unPatchPromiseForTest = function () {\n        if (!this.supportWaitUnresolvedChainedPromise) {\n          return;\n        }\n\n        var unPatchPromiseForTest = Promise[Zone.__symbol__('unPatchPromiseForTest')];\n\n        if (unPatchPromiseForTest) {\n          unPatchPromiseForTest();\n        }\n      };\n\n      AsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n        if (task.type !== 'eventTask') {\n          this._isSync = false;\n        }\n\n        if (task.type === 'microTask' && task.data && task.data instanceof Promise) {\n          // check whether the promise is a chained promise\n          if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {\n            // chained promise is being scheduled\n            this.unresolvedChainedPromiseCount--;\n          }\n        }\n\n        return delegate.scheduleTask(target, task);\n      };\n\n      AsyncTestZoneSpec.prototype.onInvokeTask = function (delegate, current, target, task, applyThis, applyArgs) {\n        if (task.type !== 'eventTask') {\n          this._isSync = false;\n        }\n\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      };\n\n      AsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n        if (task.type !== 'eventTask') {\n          this._isSync = false;\n        }\n\n        return delegate.cancelTask(target, task);\n      }; // Note - we need to use onInvoke at the moment to call finish when a test is\n      // fully synchronous. TODO(juliemr): remove this when the logic for\n      // onHasTask changes and it calls whenever the task queues are dirty.\n      // updated by(JiaLiPassion), only call finish callback when no task\n      // was scheduled/invoked/canceled.\n\n\n      AsyncTestZoneSpec.prototype.onInvoke = function (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n        try {\n          this._isSync = true;\n          return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n        } finally {\n          var afterTaskCounts = parentZoneDelegate._taskCounts;\n\n          if (this._isSync) {\n            this._finishCallbackIfDone();\n          }\n        }\n      };\n\n      AsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n        // Let the parent try to handle the error.\n        var result = parentZoneDelegate.handleError(targetZone, error);\n\n        if (result) {\n          this.failCallback(error);\n          this._alreadyErrored = true;\n        }\n\n        return false;\n      };\n\n      AsyncTestZoneSpec.prototype.onHasTask = function (delegate, current, target, hasTaskState) {\n        delegate.hasTask(target, hasTaskState);\n\n        if (hasTaskState.change == 'microTask') {\n          this._pendingMicroTasks = hasTaskState.microTask;\n\n          this._finishCallbackIfDone();\n        } else if (hasTaskState.change == 'macroTask') {\n          this._pendingMacroTasks = hasTaskState.macroTask;\n\n          this._finishCallbackIfDone();\n        }\n      };\n\n      return AsyncTestZoneSpec;\n    }();\n\n    AsyncTestZoneSpec.symbolParentUnresolved = Zone.__symbol__('parentUnresolved'); // Export the class so that new instances can be created with proper\n    // constructor params.\n\n    Zone['AsyncTestZoneSpec'] = AsyncTestZoneSpec;\n  })(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  Zone.__load_patch('asynctest', function (global, Zone, api) {\n    /**\n     * Wraps a test function in an asynchronous test zone. The test will automatically\n     * complete when all asynchronous calls within this zone are done.\n     */\n    Zone[api.symbol('asyncTest')] = function asyncTest(fn) {\n      // If we're running using the Jasmine test framework, adapt to call the 'done'\n      // function when asynchronous activity is finished.\n      if (global.jasmine) {\n        // Not using an arrow function to preserve context passed from call site\n        return function (done) {\n          if (!done) {\n            // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n            // fake it here and assume sync.\n            done = function done() {};\n\n            done.fail = function (e) {\n              throw e;\n            };\n          }\n\n          runInTestZone(fn, this, done, function (err) {\n            if (typeof err === 'string') {\n              return done.fail(new Error(err));\n            } else {\n              done.fail(err);\n            }\n          });\n        };\n      } // Otherwise, return a promise which will resolve when asynchronous activity\n      // is finished. This will be correctly consumed by the Mocha framework with\n      // it('...', async(myFn)); or can be used in a custom framework.\n      // Not using an arrow function to preserve context passed from call site\n\n\n      return function () {\n        var _this = this;\n\n        return new Promise(function (finishCallback, failCallback) {\n          runInTestZone(fn, _this, finishCallback, failCallback);\n        });\n      };\n    };\n\n    function runInTestZone(fn, context, finishCallback, failCallback) {\n      var currentZone = Zone.current;\n      var AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n\n      if (AsyncTestZoneSpec === undefined) {\n        throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/dist/async-test.js');\n      }\n\n      var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n\n      if (ProxyZoneSpec === undefined) {\n        throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/dist/proxy.js');\n      }\n\n      var proxyZoneSpec = ProxyZoneSpec.get();\n      ProxyZoneSpec.assertPresent(); // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n      // If we do it in ProxyZone then we will get to infinite recursion.\n\n      var proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n      var previousDelegate = proxyZoneSpec.getDelegate();\n      proxyZone.parent.run(function () {\n        var testZoneSpec = new AsyncTestZoneSpec(function () {\n          // Need to restore the original zone.\n          if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n            // Only reset the zone spec if it's\n            // sill this one. Otherwise, assume\n            // it's OK.\n            proxyZoneSpec.setDelegate(previousDelegate);\n          }\n\n          testZoneSpec.unPatchPromiseForTest();\n          currentZone.run(function () {\n            finishCallback();\n          });\n        }, function (error) {\n          // Need to restore the original zone.\n          if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n            // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n            proxyZoneSpec.setDelegate(previousDelegate);\n          }\n\n          testZoneSpec.unPatchPromiseForTest();\n          currentZone.run(function () {\n            failCallback(error);\n          });\n        }, 'test');\n        proxyZoneSpec.setDelegate(testZoneSpec);\n        testZoneSpec.patchPromiseForTest();\n      });\n      return Zone.current.runGuarded(fn, context);\n    }\n  });\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  (function (global) {\n    var OriginalDate = global.Date;\n\n    var FakeDate =\n    /** @class */\n    function () {\n      function FakeDate() {\n        if (arguments.length === 0) {\n          var d = new OriginalDate();\n          d.setTime(FakeDate.now());\n          return d;\n        } else {\n          var args = Array.prototype.slice.call(arguments);\n          return new (OriginalDate.bind.apply(OriginalDate, __spreadArrays([void 0], args)))();\n        }\n      }\n\n      FakeDate.now = function () {\n        var fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncTestZoneSpec) {\n          return fakeAsyncTestZoneSpec.getCurrentRealTime() + fakeAsyncTestZoneSpec.getCurrentTime();\n        }\n\n        return OriginalDate.now.apply(this, arguments);\n      };\n\n      return FakeDate;\n    }();\n\n    FakeDate.UTC = OriginalDate.UTC;\n    FakeDate.parse = OriginalDate.parse; // keep a reference for zone patched timer function\n\n    var timers = {\n      setTimeout: global.setTimeout,\n      setInterval: global.setInterval,\n      clearTimeout: global.clearTimeout,\n      clearInterval: global.clearInterval\n    };\n\n    var Scheduler =\n    /** @class */\n    function () {\n      function Scheduler() {\n        // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n        this._schedulerQueue = []; // Current simulated time in millis.\n\n        this._currentTime = 0; // Current real time in millis.\n\n        this._currentRealTime = OriginalDate.now(); // track requeuePeriodicTimer\n\n        this._currentTickRequeuePeriodicEntries = [];\n      }\n\n      Scheduler.prototype.getCurrentTime = function () {\n        return this._currentTime;\n      };\n\n      Scheduler.prototype.getCurrentRealTime = function () {\n        return this._currentRealTime;\n      };\n\n      Scheduler.prototype.setCurrentRealTime = function (realTime) {\n        this._currentRealTime = realTime;\n      };\n\n      Scheduler.prototype.scheduleFunction = function (cb, delay, options) {\n        options = Object.assign({\n          args: [],\n          isPeriodic: false,\n          isRequestAnimationFrame: false,\n          id: -1,\n          isRequeuePeriodic: false\n        }, options);\n        var currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n        var endTime = this._currentTime + delay; // Insert so that scheduler queue remains sorted by end time.\n\n        var newEntry = {\n          endTime: endTime,\n          id: currentId,\n          func: cb,\n          args: options.args,\n          delay: delay,\n          isPeriodic: options.isPeriodic,\n          isRequestAnimationFrame: options.isRequestAnimationFrame\n        };\n\n        if (options.isRequeuePeriodic) {\n          this._currentTickRequeuePeriodicEntries.push(newEntry);\n        }\n\n        var i = 0;\n\n        for (; i < this._schedulerQueue.length; i++) {\n          var currentEntry = this._schedulerQueue[i];\n\n          if (newEntry.endTime < currentEntry.endTime) {\n            break;\n          }\n        }\n\n        this._schedulerQueue.splice(i, 0, newEntry);\n\n        return currentId;\n      };\n\n      Scheduler.prototype.removeScheduledFunctionWithId = function (id) {\n        for (var i = 0; i < this._schedulerQueue.length; i++) {\n          if (this._schedulerQueue[i].id == id) {\n            this._schedulerQueue.splice(i, 1);\n\n            break;\n          }\n        }\n      };\n\n      Scheduler.prototype.tick = function (millis, doTick, tickOptions) {\n        if (millis === void 0) {\n          millis = 0;\n        }\n\n        var finalTime = this._currentTime + millis;\n        var lastCurrentTime = 0;\n        tickOptions = Object.assign({\n          processNewMacroTasksSynchronously: true\n        }, tickOptions); // we need to copy the schedulerQueue so nested timeout\n        // will not be wrongly called in the current tick\n        // https://github.com/angular/angular/issues/33799\n\n        var schedulerQueue = tickOptions.processNewMacroTasksSynchronously ? this._schedulerQueue : this._schedulerQueue.slice();\n\n        if (schedulerQueue.length === 0 && doTick) {\n          doTick(millis);\n          return;\n        }\n\n        while (schedulerQueue.length > 0) {\n          // clear requeueEntries before each loop\n          this._currentTickRequeuePeriodicEntries = [];\n          var current = schedulerQueue[0];\n\n          if (finalTime < current.endTime) {\n            // Done processing the queue since it's sorted by endTime.\n            break;\n          } else {\n            // Time to run scheduled function. Remove it from the head of queue.\n            var current_1 = schedulerQueue.shift();\n\n            if (!tickOptions.processNewMacroTasksSynchronously) {\n              var idx = this._schedulerQueue.indexOf(current_1);\n\n              if (idx >= 0) {\n                this._schedulerQueue.splice(idx, 1);\n              }\n            }\n\n            lastCurrentTime = this._currentTime;\n            this._currentTime = current_1.endTime;\n\n            if (doTick) {\n              doTick(this._currentTime - lastCurrentTime);\n            }\n\n            var retval = current_1.func.apply(global, current_1.isRequestAnimationFrame ? [this._currentTime] : current_1.args);\n\n            if (!retval) {\n              // Uncaught exception in the current scheduled function. Stop processing the queue.\n              break;\n            } // check is there any requeue periodic entry is added in\n            // current loop, if there is, we need to add to current loop\n\n\n            if (!tickOptions.processNewMacroTasksSynchronously) {\n              this._currentTickRequeuePeriodicEntries.forEach(function (newEntry) {\n                var i = 0;\n\n                for (; i < schedulerQueue.length; i++) {\n                  var currentEntry = schedulerQueue[i];\n\n                  if (newEntry.endTime < currentEntry.endTime) {\n                    break;\n                  }\n                }\n\n                schedulerQueue.splice(i, 0, newEntry);\n              });\n            }\n          }\n        }\n\n        lastCurrentTime = this._currentTime;\n        this._currentTime = finalTime;\n\n        if (doTick) {\n          doTick(this._currentTime - lastCurrentTime);\n        }\n      };\n\n      Scheduler.prototype.flush = function (limit, flushPeriodic, doTick) {\n        if (limit === void 0) {\n          limit = 20;\n        }\n\n        if (flushPeriodic === void 0) {\n          flushPeriodic = false;\n        }\n\n        if (flushPeriodic) {\n          return this.flushPeriodic(doTick);\n        } else {\n          return this.flushNonPeriodic(limit, doTick);\n        }\n      };\n\n      Scheduler.prototype.flushPeriodic = function (doTick) {\n        if (this._schedulerQueue.length === 0) {\n          return 0;\n        } // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n\n\n        var startTime = this._currentTime;\n        var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n        this.tick(lastTask.endTime - startTime, doTick);\n        return this._currentTime - startTime;\n      };\n\n      Scheduler.prototype.flushNonPeriodic = function (limit, doTick) {\n        var startTime = this._currentTime;\n        var lastCurrentTime = 0;\n        var count = 0;\n\n        while (this._schedulerQueue.length > 0) {\n          count++;\n\n          if (count > limit) {\n            throw new Error('flush failed after reaching the limit of ' + limit + ' tasks. Does your code use a polling timeout?');\n          } // flush only non-periodic timers.\n          // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n\n\n          if (this._schedulerQueue.filter(function (task) {\n            return !task.isPeriodic && !task.isRequestAnimationFrame;\n          }).length === 0) {\n            break;\n          }\n\n          var current = this._schedulerQueue.shift();\n\n          lastCurrentTime = this._currentTime;\n          this._currentTime = current.endTime;\n\n          if (doTick) {\n            // Update any secondary schedulers like Jasmine mock Date.\n            doTick(this._currentTime - lastCurrentTime);\n          }\n\n          var retval = current.func.apply(global, current.args);\n\n          if (!retval) {\n            // Uncaught exception in the current scheduled function. Stop processing the queue.\n            break;\n          }\n        }\n\n        return this._currentTime - startTime;\n      };\n\n      return Scheduler;\n    }(); // Next scheduler id.\n\n\n    Scheduler.nextId = 1;\n\n    var FakeAsyncTestZoneSpec =\n    /** @class */\n    function () {\n      function FakeAsyncTestZoneSpec(namePrefix, trackPendingRequestAnimationFrame, macroTaskOptions) {\n        if (trackPendingRequestAnimationFrame === void 0) {\n          trackPendingRequestAnimationFrame = false;\n        }\n\n        this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n        this.macroTaskOptions = macroTaskOptions;\n        this._scheduler = new Scheduler();\n        this._microtasks = [];\n        this._lastError = null;\n        this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n        this.pendingPeriodicTimers = [];\n        this.pendingTimers = [];\n        this.patchDateLocked = false;\n        this.properties = {\n          'FakeAsyncTestZoneSpec': this\n        };\n        this.name = 'fakeAsyncTestZone for ' + namePrefix; // in case user can't access the construction of FakeAsyncTestSpec\n        // user can also define macroTaskOptions by define a global variable.\n\n        if (!this.macroTaskOptions) {\n          this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n        }\n      }\n\n      FakeAsyncTestZoneSpec.assertInZone = function () {\n        if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n          throw new Error('The code should be running in the fakeAsync zone to call this function');\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype._fnAndFlush = function (fn, completers) {\n        var _this = this;\n\n        return function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          fn.apply(global, args);\n\n          if (_this._lastError === null) {\n            // Success\n            if (completers.onSuccess != null) {\n              completers.onSuccess.apply(global);\n            } // Flush microtasks only on success.\n\n\n            _this.flushMicrotasks();\n          } else {\n            // Failure\n            if (completers.onError != null) {\n              completers.onError.apply(global);\n            }\n          } // Return true if there were no errors, false otherwise.\n\n\n          return _this._lastError === null;\n        };\n      };\n\n      FakeAsyncTestZoneSpec._removeTimer = function (timers, id) {\n        var index = timers.indexOf(id);\n\n        if (index > -1) {\n          timers.splice(index, 1);\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype._dequeueTimer = function (id) {\n        var _this = this;\n\n        return function () {\n          FakeAsyncTestZoneSpec._removeTimer(_this.pendingTimers, id);\n        };\n      };\n\n      FakeAsyncTestZoneSpec.prototype._requeuePeriodicTimer = function (fn, interval, args, id) {\n        var _this = this;\n\n        return function () {\n          // Requeue the timer callback if it's not been canceled.\n          if (_this.pendingPeriodicTimers.indexOf(id) !== -1) {\n            _this._scheduler.scheduleFunction(fn, interval, {\n              args: args,\n              isPeriodic: true,\n              id: id,\n              isRequeuePeriodic: true\n            });\n          }\n        };\n      };\n\n      FakeAsyncTestZoneSpec.prototype._dequeuePeriodicTimer = function (id) {\n        var _this = this;\n\n        return function () {\n          FakeAsyncTestZoneSpec._removeTimer(_this.pendingPeriodicTimers, id);\n        };\n      };\n\n      FakeAsyncTestZoneSpec.prototype._setTimeout = function (fn, delay, args, isTimer) {\n        if (isTimer === void 0) {\n          isTimer = true;\n        }\n\n        var removeTimerFn = this._dequeueTimer(Scheduler.nextId); // Queue the callback and dequeue the timer on success and error.\n\n\n        var cb = this._fnAndFlush(fn, {\n          onSuccess: removeTimerFn,\n          onError: removeTimerFn\n        });\n\n        var id = this._scheduler.scheduleFunction(cb, delay, {\n          args: args,\n          isRequestAnimationFrame: !isTimer\n        });\n\n        if (isTimer) {\n          this.pendingTimers.push(id);\n        }\n\n        return id;\n      };\n\n      FakeAsyncTestZoneSpec.prototype._clearTimeout = function (id) {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n\n        this._scheduler.removeScheduledFunctionWithId(id);\n      };\n\n      FakeAsyncTestZoneSpec.prototype._setInterval = function (fn, interval, args) {\n        var id = Scheduler.nextId;\n        var completers = {\n          onSuccess: null,\n          onError: this._dequeuePeriodicTimer(id)\n        };\n\n        var cb = this._fnAndFlush(fn, completers); // Use the callback created above to requeue on success.\n\n\n        completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id); // Queue the callback and dequeue the periodic timer only on error.\n\n        this._scheduler.scheduleFunction(cb, interval, {\n          args: args,\n          isPeriodic: true\n        });\n\n        this.pendingPeriodicTimers.push(id);\n        return id;\n      };\n\n      FakeAsyncTestZoneSpec.prototype._clearInterval = function (id) {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n\n        this._scheduler.removeScheduledFunctionWithId(id);\n      };\n\n      FakeAsyncTestZoneSpec.prototype._resetLastErrorAndThrow = function () {\n        var error = this._lastError || this._uncaughtPromiseErrors[0];\n        this._uncaughtPromiseErrors.length = 0;\n        this._lastError = null;\n        throw error;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.getCurrentTime = function () {\n        return this._scheduler.getCurrentTime();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.getCurrentRealTime = function () {\n        return this._scheduler.getCurrentRealTime();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.setCurrentRealTime = function (realTime) {\n        this._scheduler.setCurrentRealTime(realTime);\n      };\n\n      FakeAsyncTestZoneSpec.patchDate = function () {\n        if (!!global[Zone.__symbol__('disableDatePatching')]) {\n          // we don't want to patch global Date\n          // because in some case, global Date\n          // is already being patched, we need to provide\n          // an option to let user still use their\n          // own version of Date.\n          return;\n        }\n\n        if (global['Date'] === FakeDate) {\n          // already patched\n          return;\n        }\n\n        global['Date'] = FakeDate;\n        FakeDate.prototype = OriginalDate.prototype; // try check and reset timers\n        // because jasmine.clock().install() may\n        // have replaced the global timer\n\n        FakeAsyncTestZoneSpec.checkTimerPatch();\n      };\n\n      FakeAsyncTestZoneSpec.resetDate = function () {\n        if (global['Date'] === FakeDate) {\n          global['Date'] = OriginalDate;\n        }\n      };\n\n      FakeAsyncTestZoneSpec.checkTimerPatch = function () {\n        if (global.setTimeout !== timers.setTimeout) {\n          global.setTimeout = timers.setTimeout;\n          global.clearTimeout = timers.clearTimeout;\n        }\n\n        if (global.setInterval !== timers.setInterval) {\n          global.setInterval = timers.setInterval;\n          global.clearInterval = timers.clearInterval;\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.lockDatePatch = function () {\n        this.patchDateLocked = true;\n        FakeAsyncTestZoneSpec.patchDate();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.unlockDatePatch = function () {\n        this.patchDateLocked = false;\n        FakeAsyncTestZoneSpec.resetDate();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.tick = function (millis, doTick, tickOptions) {\n        if (millis === void 0) {\n          millis = 0;\n        }\n\n        if (tickOptions === void 0) {\n          tickOptions = {\n            processNewMacroTasksSynchronously: true\n          };\n        }\n\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        this._scheduler.tick(millis, doTick, tickOptions);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.flushMicrotasks = function () {\n        var _this = this;\n\n        FakeAsyncTestZoneSpec.assertInZone();\n\n        var flushErrors = function flushErrors() {\n          if (_this._lastError !== null || _this._uncaughtPromiseErrors.length) {\n            // If there is an error stop processing the microtask queue and rethrow the error.\n            _this._resetLastErrorAndThrow();\n          }\n        };\n\n        while (this._microtasks.length > 0) {\n          var microtask = this._microtasks.shift();\n\n          microtask.func.apply(microtask.target, microtask.args);\n        }\n\n        flushErrors();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.flush = function (limit, flushPeriodic, doTick) {\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        var elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n\n        return elapsed;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n        switch (task.type) {\n          case 'microTask':\n            var args = task.data && task.data.args; // should pass additional arguments to callback if have any\n            // currently we know process.nextTick will have such additional\n            // arguments\n\n            var additionalArgs = void 0;\n\n            if (args) {\n              var callbackIndex = task.data.cbIdx;\n\n              if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n                additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n              }\n            }\n\n            this._microtasks.push({\n              func: task.invoke,\n              args: additionalArgs,\n              target: task.data && task.data.target\n            });\n\n            break;\n\n          case 'macroTask':\n            switch (task.source) {\n              case 'setTimeout':\n                task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                break;\n\n              case 'setImmediate':\n                task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n                break;\n\n              case 'setInterval':\n                task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                break;\n\n              case 'XMLHttpRequest.send':\n                throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' + task.data['url']);\n\n              case 'requestAnimationFrame':\n              case 'webkitRequestAnimationFrame':\n              case 'mozRequestAnimationFrame':\n                // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n                // (60 frames per second)\n                task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n                break;\n\n              default:\n                // user can define which macroTask they want to support by passing\n                // macroTaskOptions\n                var macroTaskOption = this.findMacroTaskOption(task);\n\n                if (macroTaskOption) {\n                  var args_1 = task.data && task.data['args'];\n                  var delay = args_1 && args_1.length > 1 ? args_1[1] : 0;\n                  var callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args_1;\n\n                  if (!!macroTaskOption.isPeriodic) {\n                    // periodic macroTask, use setInterval to simulate\n                    task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                    task.data.isPeriodic = true;\n                  } else {\n                    // not periodic, use setTimeout to simulate\n                    task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                  }\n\n                  break;\n                }\n\n                throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n            }\n\n            break;\n\n          case 'eventTask':\n            task = delegate.scheduleTask(target, task);\n            break;\n        }\n\n        return task;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n        switch (task.source) {\n          case 'setTimeout':\n          case 'requestAnimationFrame':\n          case 'webkitRequestAnimationFrame':\n          case 'mozRequestAnimationFrame':\n            return this._clearTimeout(task.data['handleId']);\n\n          case 'setInterval':\n            return this._clearInterval(task.data['handleId']);\n\n          default:\n            // user can define which macroTask they want to support by passing\n            // macroTaskOptions\n            var macroTaskOption = this.findMacroTaskOption(task);\n\n            if (macroTaskOption) {\n              var handleId = task.data['handleId'];\n              return macroTaskOption.isPeriodic ? this._clearInterval(handleId) : this._clearTimeout(handleId);\n            }\n\n            return delegate.cancelTask(target, task);\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onInvoke = function (delegate, current, target, callback, applyThis, applyArgs, source) {\n        try {\n          FakeAsyncTestZoneSpec.patchDate();\n          return delegate.invoke(target, callback, applyThis, applyArgs, source);\n        } finally {\n          if (!this.patchDateLocked) {\n            FakeAsyncTestZoneSpec.resetDate();\n          }\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.findMacroTaskOption = function (task) {\n        if (!this.macroTaskOptions) {\n          return null;\n        }\n\n        for (var i = 0; i < this.macroTaskOptions.length; i++) {\n          var macroTaskOption = this.macroTaskOptions[i];\n\n          if (macroTaskOption.source === task.source) {\n            return macroTaskOption;\n          }\n        }\n\n        return null;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n        this._lastError = error;\n        return false; // Don't propagate error to parent zone.\n      };\n\n      return FakeAsyncTestZoneSpec;\n    }(); // Export the class so that new instances can be created with proper\n    // constructor params.\n\n\n    Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n  })(typeof window === 'object' && window || typeof self === 'object' && self || global);\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  Zone.__load_patch('fakeasync', function (global, Zone, api) {\n    var FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n    var ProxyZoneSpec = Zone && Zone['ProxyZoneSpec'];\n    var _fakeAsyncTestZoneSpec = null;\n    /**\n     * Clears out the shared fake async zone for a test.\n     * To be called in a global `beforeEach`.\n     *\n     * @experimental\n     */\n\n    function resetFakeAsyncZone() {\n      if (_fakeAsyncTestZoneSpec) {\n        _fakeAsyncTestZoneSpec.unlockDatePatch();\n      }\n\n      _fakeAsyncTestZoneSpec = null; // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n\n      ProxyZoneSpec && ProxyZoneSpec.assertPresent().resetDelegate();\n    }\n    /**\n     * Wraps a function to be executed in the fakeAsync zone:\n     * - microtasks are manually executed by calling `flushMicrotasks()`,\n     * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n     *\n     * If there are any pending timers at the end of the function, an exception will be thrown.\n     *\n     * Can be used to wrap inject() calls.\n     *\n     * ## Example\n     *\n     * {@example core/testing/ts/fake_async.ts region='basic'}\n     *\n     * @param fn\n     * @returns The function wrapped to be executed in the fakeAsync zone\n     *\n     * @experimental\n     */\n\n\n    function fakeAsync(fn) {\n      // Not using an arrow function to preserve context passed from call site\n      return function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        var proxyZoneSpec = ProxyZoneSpec.assertPresent();\n\n        if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n          throw new Error('fakeAsync() calls can not be nested');\n        }\n\n        try {\n          // in case jasmine.clock init a fakeAsyncTestZoneSpec\n          if (!_fakeAsyncTestZoneSpec) {\n            if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n              throw new Error('fakeAsync() calls can not be nested');\n            }\n\n            _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n          }\n\n          var res = void 0;\n          var lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n          proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n\n          _fakeAsyncTestZoneSpec.lockDatePatch();\n\n          try {\n            res = fn.apply(this, args);\n            flushMicrotasks();\n          } finally {\n            proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n          }\n\n          if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n            throw new Error(_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length + \" \" + \"periodic timer(s) still in the queue.\");\n          }\n\n          if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n            throw new Error(_fakeAsyncTestZoneSpec.pendingTimers.length + \" timer(s) still in the queue.\");\n          }\n\n          return res;\n        } finally {\n          resetFakeAsyncZone();\n        }\n      };\n    }\n\n    function _getFakeAsyncZoneSpec() {\n      if (_fakeAsyncTestZoneSpec == null) {\n        _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (_fakeAsyncTestZoneSpec == null) {\n          throw new Error('The code should be running in the fakeAsync zone to call this function');\n        }\n      }\n\n      return _fakeAsyncTestZoneSpec;\n    }\n    /**\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n     *\n     * The microtasks queue is drained at the very start of this function and after any timer callback\n     * has been executed.\n     *\n     * ## Example\n     *\n     * {@example core/testing/ts/fake_async.ts region='basic'}\n     *\n     * @experimental\n     */\n\n\n    function tick(millis, ignoreNestedTimeout) {\n      if (millis === void 0) {\n        millis = 0;\n      }\n\n      if (ignoreNestedTimeout === void 0) {\n        ignoreNestedTimeout = false;\n      }\n\n      _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n    }\n    /**\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n     * draining the macrotask queue until it is empty. The returned value is the milliseconds\n     * of time that would have been elapsed.\n     *\n     * @param maxTurns\n     * @returns The simulated time elapsed, in millis.\n     *\n     * @experimental\n     */\n\n\n    function flush(maxTurns) {\n      return _getFakeAsyncZoneSpec().flush(maxTurns);\n    }\n    /**\n     * Discard all remaining periodic tasks.\n     *\n     * @experimental\n     */\n\n\n    function discardPeriodicTasks() {\n      var zoneSpec = _getFakeAsyncZoneSpec();\n\n      var pendingTimers = zoneSpec.pendingPeriodicTimers;\n      zoneSpec.pendingPeriodicTimers.length = 0;\n    }\n    /**\n     * Flush any pending microtasks.\n     *\n     * @experimental\n     */\n\n\n    function flushMicrotasks() {\n      _getFakeAsyncZoneSpec().flushMicrotasks();\n    }\n\n    Zone[api.symbol('fakeAsyncTest')] = {\n      resetFakeAsyncZone: resetFakeAsyncZone,\n      flushMicrotasks: flushMicrotasks,\n      discardPeriodicTasks: discardPeriodicTasks,\n      tick: tick,\n      flush: flush,\n      fakeAsync: fakeAsync\n    };\n  });\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  /**\n   * Promise for async/fakeAsync zoneSpec test\n   * can support async operation which not supported by zone.js\n   * such as\n   * it ('test jsonp in AsyncZone', async() => {\n   *   new Promise(res => {\n   *     jsonp(url, (data) => {\n   *       // success callback\n   *       res(data);\n   *     });\n   *   }).then((jsonpResult) => {\n   *     // get jsonp result.\n   *\n   *     // user will expect AsyncZoneSpec wait for\n   *     // then, but because jsonp is not zone aware\n   *     // AsyncZone will finish before then is called.\n   *   });\n   * });\n   */\n\n\n  Zone.__load_patch('promisefortest', function (global, Zone, api) {\n    var symbolState = api.symbol('state');\n    var UNRESOLVED = null;\n    var symbolParentUnresolved = api.symbol('parentUnresolved'); // patch Promise.prototype.then to keep an internal\n    // number for tracking unresolved chained promise\n    // we will decrease this number when the parent promise\n    // being resolved/rejected and chained promise was\n    // scheduled as a microTask.\n    // so we can know such kind of chained promise still\n    // not resolved in AsyncTestZone\n\n    Promise[api.symbol('patchPromiseForTest')] = function patchPromiseForTest() {\n      var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n\n      if (oriThen) {\n        return;\n      }\n\n      oriThen = Promise[Zone.__symbol__('ZonePromiseThen')] = Promise.prototype.then;\n\n      Promise.prototype.then = function () {\n        var chained = oriThen.apply(this, arguments);\n\n        if (this[symbolState] === UNRESOLVED) {\n          // parent promise is unresolved.\n          var asyncTestZoneSpec = Zone.current.get('AsyncTestZoneSpec');\n\n          if (asyncTestZoneSpec) {\n            asyncTestZoneSpec.unresolvedChainedPromiseCount++;\n            chained[symbolParentUnresolved] = true;\n          }\n        }\n\n        return chained;\n      };\n    };\n\n    Promise[api.symbol('unPatchPromiseForTest')] = function unpatchPromiseForTest() {\n      // restore origin then\n      var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n\n      if (oriThen) {\n        Promise.prototype.then = oriThen;\n        Promise[Zone.__symbol__('ZonePromiseThen')] = undefined;\n      }\n    };\n  });\n});",
  "map": {
    "version": 3,
    "sources": ["c:/Users/manoel.vitor/Desktop/teste/po/po-angular/node_modules/zone.js/dist/zone-testing.js"],
    "names": [
      "__spreadArrays",
      "s",
      "i",
      "il",
      "arguments",
      "length",
      "r",
      "Array",
      "k",
      "a",
      "j",
      "jl",
      "factory",
      "define",
      "amd",
      "NEWLINE",
      "IGNORE_FRAMES",
      "creationTrace",
      "ERROR_TAG",
      "SEP_TAG",
      "sepTemplate",
      "LongStackTrace",
      "error",
      "getStacktrace",
      "timestamp",
      "Date",
      "getStacktraceWithUncaughtError",
      "Error",
      "getStacktraceWithCaughtError",
      "err",
      "caughtError",
      "stack",
      "getFrames",
      "split",
      "addErrorStack",
      "lines",
      "trace",
      "frame",
      "hasOwnProperty",
      "push",
      "renderLongStackTrace",
      "frames",
      "longTrace",
      "trim",
      "getTime",
      "traceFrames",
      "lastTime",
      "separator",
      "replace",
      "join",
      "stackTracesEnabled",
      "stackTraceLimit",
      "Zone",
      "name",
      "longStackTraceLimit",
      "getLongStackTrace",
      "undefined",
      "__symbol__",
      "onScheduleTask",
      "parentZoneDelegate",
      "currentZone",
      "targetZone",
      "task",
      "currentTask",
      "data",
      "concat",
      "type",
      "Object",
      "assign",
      "scheduleTask",
      "onHandleError",
      "parentTask",
      "longStack",
      "handleError",
      "captureStackTraces",
      "stackTraces",
      "count",
      "computeIgnoreFrames",
      "frames1",
      "frames2",
      "frame1",
      "indexOf",
      "match",
      "frame2",
      "ProxyZoneSpec",
      "defaultSpecDelegate",
      "_delegateSpec",
      "properties",
      "propertyKeys",
      "lastTaskState",
      "isNeedToTriggerHasTask",
      "tasks",
      "setDelegate",
      "get",
      "current",
      "isLoaded",
      "assertPresent",
      "prototype",
      "delegateSpec",
      "_this",
      "isNewDelegate",
      "forEach",
      "key",
      "keys",
      "macroTask",
      "microTask",
      "getDelegate",
      "resetDelegate",
      "tryTriggerHasTask",
      "onHasTask",
      "removeFromTasks",
      "splice",
      "getAndClearPendingTasksInfo",
      "taskInfo",
      "map",
      "dataInfo",
      "source",
      "pendingTasksInfo",
      "onFork",
      "zoneSpec",
      "fork",
      "onIntercept",
      "delegate",
      "intercept",
      "onInvoke",
      "applyThis",
      "applyArgs",
      "invoke",
      "onInvokeTask",
      "invokeTask",
      "onCancelTask",
      "cancelTask",
      "target",
      "hasTaskState",
      "hasTask",
      "SyncTestZoneSpec",
      "namePrefix",
      "runZone",
      "__load_patch",
      "global",
      "api",
      "__extends",
      "d",
      "b",
      "p",
      "__",
      "constructor",
      "create",
      "jest",
      "jasmine",
      "ambientZone",
      "syncZone",
      "symbol",
      "disablePatchingJasmineClock",
      "enableAutoFakeAsyncWhenClockPatched",
      "ignoreUnhandledRejection",
      "globalErrors_1",
      "GlobalErrors",
      "instance",
      "originalInstall",
      "install",
      "originalHandlers",
      "process",
      "listeners",
      "apply",
      "removeAllListeners",
      "h",
      "on",
      "jasmineEnv",
      "getEnv",
      "methodName",
      "originalJasmineFn",
      "description",
      "specDefinitions",
      "call",
      "wrapDescribeInZone",
      "timeout",
      "wrapTestInZone",
      "originalClockFn_1",
      "clock",
      "originalTick_1",
      "tick",
      "fakeAsyncZoneSpec",
      "originalMockDate_1",
      "mockDate",
      "dateTime",
      "setCurrentRealTime",
      "originalClockFn",
      "FakeAsyncTestZoneSpec",
      "describeBody",
      "run",
      "runInTestZone",
      "testBody",
      "queueRunner",
      "done",
      "isClockInstalled",
      "testProxyZoneSpec",
      "testProxyZone",
      "fakeAsyncModule",
      "fakeAsync",
      "QueueRunner",
      "_super",
      "ZoneQueueRunner",
      "attrs",
      "onComplete",
      "fn",
      "scheduleMicroTask",
      "nativeSetTimeout",
      "nativeClearTimeout",
      "setTimeout",
      "clearTimeout",
      "UserContext",
      "userContext",
      "onException",
      "message",
      "proxyZoneSpec",
      "execute",
      "zone",
      "isChildOfAmbientZone",
      "parent",
      "context",
      "rootZone",
      "proxyZone",
      "wrapDescribeFactoryInZone",
      "originalJestFn",
      "tableArgs",
      "_i",
      "originalDescribeFn",
      "args",
      "wrapTestFactoryInZone",
      "testFn",
      "each",
      "describe",
      "only",
      "fdescribe",
      "skip",
      "xdescribe",
      "todo",
      "it",
      "fit",
      "xit",
      "test",
      "Mocha",
      "testZone",
      "suiteZone",
      "mochaOriginal",
      "after",
      "afterEach",
      "before",
      "beforeEach",
      "modifyArguments",
      "syncTest",
      "asyncTest",
      "_loop_1",
      "arg",
      "toString",
      "wrapSuiteInZone",
      "suite",
      "specify",
      "xspecify",
      "suiteTeardown",
      "teardown",
      "suiteSetup",
      "setup",
      "originalRunTest",
      "originalRun",
      "Runner",
      "runTest",
      "e",
      "_global",
      "AsyncTestZoneSpec",
      "finishCallback",
      "failCallback",
      "_pendingMicroTasks",
      "_pendingMacroTasks",
      "_alreadyErrored",
      "_isSync",
      "unresolvedChainedPromiseCount",
      "supportWaitUnresolvedChainedPromise",
      "isUnresolvedChainedPromisePending",
      "_finishCallbackIfDone",
      "patchPromiseForTest",
      "Promise",
      "unPatchPromiseForTest",
      "symbolParentUnresolved",
      "afterTaskCounts",
      "_taskCounts",
      "result",
      "change",
      "window",
      "self",
      "fail",
      "getZoneWith",
      "previousDelegate",
      "testZoneSpec",
      "runGuarded",
      "OriginalDate",
      "FakeDate",
      "setTime",
      "now",
      "slice",
      "bind",
      "fakeAsyncTestZoneSpec",
      "getCurrentRealTime",
      "getCurrentTime",
      "UTC",
      "parse",
      "timers",
      "setInterval",
      "clearInterval",
      "Scheduler",
      "_schedulerQueue",
      "_currentTime",
      "_currentRealTime",
      "_currentTickRequeuePeriodicEntries",
      "realTime",
      "scheduleFunction",
      "cb",
      "delay",
      "options",
      "isPeriodic",
      "isRequestAnimationFrame",
      "id",
      "isRequeuePeriodic",
      "currentId",
      "nextId",
      "endTime",
      "newEntry",
      "func",
      "currentEntry",
      "removeScheduledFunctionWithId",
      "millis",
      "doTick",
      "tickOptions",
      "finalTime",
      "lastCurrentTime",
      "processNewMacroTasksSynchronously",
      "schedulerQueue",
      "current_1",
      "shift",
      "idx",
      "retval",
      "flush",
      "limit",
      "flushPeriodic",
      "flushNonPeriodic",
      "startTime",
      "lastTask",
      "filter",
      "trackPendingRequestAnimationFrame",
      "macroTaskOptions",
      "_scheduler",
      "_microtasks",
      "_lastError",
      "_uncaughtPromiseErrors",
      "pendingPeriodicTimers",
      "pendingTimers",
      "patchDateLocked",
      "assertInZone",
      "_fnAndFlush",
      "completers",
      "onSuccess",
      "flushMicrotasks",
      "onError",
      "_removeTimer",
      "index",
      "_dequeueTimer",
      "_requeuePeriodicTimer",
      "interval",
      "_dequeuePeriodicTimer",
      "_setTimeout",
      "isTimer",
      "removeTimerFn",
      "_clearTimeout",
      "_setInterval",
      "_clearInterval",
      "_resetLastErrorAndThrow",
      "patchDate",
      "checkTimerPatch",
      "resetDate",
      "lockDatePatch",
      "unlockDatePatch",
      "flushErrors",
      "microtask",
      "elapsed",
      "additionalArgs",
      "callbackIndex",
      "cbIdx",
      "macroTaskOption",
      "findMacroTaskOption",
      "args_1",
      "callbackArgs",
      "handleId",
      "callback",
      "_fakeAsyncTestZoneSpec",
      "resetFakeAsyncZone",
      "res",
      "lastProxyZoneSpec",
      "_getFakeAsyncZoneSpec",
      "ignoreNestedTimeout",
      "maxTurns",
      "discardPeriodicTasks",
      "symbolState",
      "UNRESOLVED",
      "oriThen",
      "then",
      "chained",
      "asyncTestZoneSpec",
      "unpatchPromiseForTest"
    ],
    "mappings": "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",
    "sourcesContent": [
      "var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\n/**\n* @license Angular v9.1.0-next.4+61.sha-e552591.with-local-changes\n* (c) 2010-2020 Google LLC. https://angular.io/\n* License: MIT\n*/\n(function (factory) {\n    typeof define === 'function' && define.amd ? define(factory) :\n        factory();\n}((function () {\n    'use strict';\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * @fileoverview\n     * @suppress {globalThis}\n     */\n    var NEWLINE = '\\n';\n    var IGNORE_FRAMES = {};\n    var creationTrace = '__creationTrace__';\n    var ERROR_TAG = 'STACKTRACE TRACKING';\n    var SEP_TAG = '__SEP_TAG__';\n    var sepTemplate = SEP_TAG + '@[native]';\n    var LongStackTrace = /** @class */ (function () {\n        function LongStackTrace() {\n            this.error = getStacktrace();\n            this.timestamp = new Date();\n        }\n        return LongStackTrace;\n    }());\n    function getStacktraceWithUncaughtError() {\n        return new Error(ERROR_TAG);\n    }\n    function getStacktraceWithCaughtError() {\n        try {\n            throw getStacktraceWithUncaughtError();\n        }\n        catch (err) {\n            return err;\n        }\n    }\n    // Some implementations of exception handling don't create a stack trace if the exception\n    // isn't thrown, however it's faster not to actually throw the exception.\n    var error = getStacktraceWithUncaughtError();\n    var caughtError = getStacktraceWithCaughtError();\n    var getStacktrace = error.stack ?\n        getStacktraceWithUncaughtError :\n        (caughtError.stack ? getStacktraceWithCaughtError : getStacktraceWithUncaughtError);\n    function getFrames(error) {\n        return error.stack ? error.stack.split(NEWLINE) : [];\n    }\n    function addErrorStack(lines, error) {\n        var trace = getFrames(error);\n        for (var i = 0; i < trace.length; i++) {\n            var frame = trace[i];\n            // Filter out the Frames which are part of stack capturing.\n            if (!IGNORE_FRAMES.hasOwnProperty(frame)) {\n                lines.push(trace[i]);\n            }\n        }\n    }\n    function renderLongStackTrace(frames, stack) {\n        var longTrace = [stack ? stack.trim() : ''];\n        if (frames) {\n            var timestamp = new Date().getTime();\n            for (var i = 0; i < frames.length; i++) {\n                var traceFrames = frames[i];\n                var lastTime = traceFrames.timestamp;\n                var separator = \"____________________Elapsed \" + (timestamp - lastTime.getTime()) + \" ms; At: \" + lastTime;\n                separator = separator.replace(/[^\\w\\d]/g, '_');\n                longTrace.push(sepTemplate.replace(SEP_TAG, separator));\n                addErrorStack(longTrace, traceFrames.error);\n                timestamp = lastTime.getTime();\n            }\n        }\n        return longTrace.join(NEWLINE);\n    }\n    // if Error.stackTraceLimit is 0, means stack trace\n    // is disabled, so we don't need to generate long stack trace\n    // this will improve performance in some test(some test will\n    // set stackTraceLimit to 0, https://github.com/angular/zone.js/issues/698\n    function stackTracesEnabled() {\n        // Cast through any since this property only exists on Error in the nodejs\n        // typings.\n        return Error.stackTraceLimit > 0;\n    }\n    Zone['longStackTraceZoneSpec'] = {\n        name: 'long-stack-trace',\n        longStackTraceLimit: 10,\n        // add a getLongStackTrace method in spec to\n        // handle handled reject promise error.\n        getLongStackTrace: function (error) {\n            if (!error) {\n                return undefined;\n            }\n            var trace = error[Zone.__symbol__('currentTaskTrace')];\n            if (!trace) {\n                return error.stack;\n            }\n            return renderLongStackTrace(trace, error.stack);\n        },\n        onScheduleTask: function (parentZoneDelegate, currentZone, targetZone, task) {\n            if (stackTracesEnabled()) {\n                var currentTask = Zone.currentTask;\n                var trace = currentTask && currentTask.data && currentTask.data[creationTrace] || [];\n                trace = [new LongStackTrace()].concat(trace);\n                if (trace.length > this.longStackTraceLimit) {\n                    trace.length = this.longStackTraceLimit;\n                }\n                if (!task.data)\n                    task.data = {};\n                if (task.type === 'eventTask') {\n                    // Fix issue https://github.com/angular/zone.js/issues/1195,\n                    // For event task of browser, by default, all task will share a\n                    // singleton instance of data object, we should create a new one here\n                    // The cast to `any` is required to workaround a closure bug which wrongly applies\n                    // URL sanitization rules to .data access.\n                    task.data = Object.assign({}, task.data);\n                }\n                task.data[creationTrace] = trace;\n            }\n            return parentZoneDelegate.scheduleTask(targetZone, task);\n        },\n        onHandleError: function (parentZoneDelegate, currentZone, targetZone, error) {\n            if (stackTracesEnabled()) {\n                var parentTask = Zone.currentTask || error.task;\n                if (error instanceof Error && parentTask) {\n                    var longStack = renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error.stack);\n                    try {\n                        error.stack = error.longStack = longStack;\n                    }\n                    catch (err) {\n                    }\n                }\n            }\n            return parentZoneDelegate.handleError(targetZone, error);\n        }\n    };\n    function captureStackTraces(stackTraces, count) {\n        if (count > 0) {\n            stackTraces.push(getFrames((new LongStackTrace()).error));\n            captureStackTraces(stackTraces, count - 1);\n        }\n    }\n    function computeIgnoreFrames() {\n        if (!stackTracesEnabled()) {\n            return;\n        }\n        var frames = [];\n        captureStackTraces(frames, 2);\n        var frames1 = frames[0];\n        var frames2 = frames[1];\n        for (var i = 0; i < frames1.length; i++) {\n            var frame1 = frames1[i];\n            if (frame1.indexOf(ERROR_TAG) == -1) {\n                var match = frame1.match(/^\\s*at\\s+/);\n                if (match) {\n                    sepTemplate = match[0] + SEP_TAG + ' (http://localhost)';\n                    break;\n                }\n            }\n        }\n        for (var i = 0; i < frames1.length; i++) {\n            var frame1 = frames1[i];\n            var frame2 = frames2[i];\n            if (frame1 === frame2) {\n                IGNORE_FRAMES[frame1] = true;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    computeIgnoreFrames();\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var ProxyZoneSpec = /** @class */ (function () {\n        function ProxyZoneSpec(defaultSpecDelegate) {\n            if (defaultSpecDelegate === void 0) { defaultSpecDelegate = null; }\n            this.defaultSpecDelegate = defaultSpecDelegate;\n            this.name = 'ProxyZone';\n            this._delegateSpec = null;\n            this.properties = { 'ProxyZoneSpec': this };\n            this.propertyKeys = null;\n            this.lastTaskState = null;\n            this.isNeedToTriggerHasTask = false;\n            this.tasks = [];\n            this.setDelegate(defaultSpecDelegate);\n        }\n        ProxyZoneSpec.get = function () { return Zone.current.get('ProxyZoneSpec'); };\n        ProxyZoneSpec.isLoaded = function () { return ProxyZoneSpec.get() instanceof ProxyZoneSpec; };\n        ProxyZoneSpec.assertPresent = function () {\n            if (!ProxyZoneSpec.isLoaded()) {\n                throw new Error(\"Expected to be running in 'ProxyZone', but it was not found.\");\n            }\n            return ProxyZoneSpec.get();\n        };\n        ProxyZoneSpec.prototype.setDelegate = function (delegateSpec) {\n            var _this = this;\n            var isNewDelegate = this._delegateSpec !== delegateSpec;\n            this._delegateSpec = delegateSpec;\n            this.propertyKeys && this.propertyKeys.forEach(function (key) { return delete _this.properties[key]; });\n            this.propertyKeys = null;\n            if (delegateSpec && delegateSpec.properties) {\n                this.propertyKeys = Object.keys(delegateSpec.properties);\n                this.propertyKeys.forEach(function (k) { return _this.properties[k] = delegateSpec.properties[k]; });\n            }\n            // if a new delegateSpec was set, check if we need to trigger hasTask\n            if (isNewDelegate && this.lastTaskState &&\n                (this.lastTaskState.macroTask || this.lastTaskState.microTask)) {\n                this.isNeedToTriggerHasTask = true;\n            }\n        };\n        ProxyZoneSpec.prototype.getDelegate = function () { return this._delegateSpec; };\n        ProxyZoneSpec.prototype.resetDelegate = function () {\n            var delegateSpec = this.getDelegate();\n            this.setDelegate(this.defaultSpecDelegate);\n        };\n        ProxyZoneSpec.prototype.tryTriggerHasTask = function (parentZoneDelegate, currentZone, targetZone) {\n            if (this.isNeedToTriggerHasTask && this.lastTaskState) {\n                // last delegateSpec has microTask or macroTask\n                // should call onHasTask in current delegateSpec\n                this.isNeedToTriggerHasTask = false;\n                this.onHasTask(parentZoneDelegate, currentZone, targetZone, this.lastTaskState);\n            }\n        };\n        ProxyZoneSpec.prototype.removeFromTasks = function (task) {\n            if (!this.tasks) {\n                return;\n            }\n            for (var i = 0; i < this.tasks.length; i++) {\n                if (this.tasks[i] === task) {\n                    this.tasks.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        ProxyZoneSpec.prototype.getAndClearPendingTasksInfo = function () {\n            if (this.tasks.length === 0) {\n                return '';\n            }\n            var taskInfo = this.tasks.map(function (task) {\n                var dataInfo = task.data &&\n                    Object.keys(task.data)\n                        .map(function (key) { return key + ':' + task.data[key]; })\n                        .join(',');\n                return \"type: \" + task.type + \", source: \" + task.source + \", args: {\" + dataInfo + \"}\";\n            });\n            var pendingTasksInfo = '--Pending async tasks are: [' + taskInfo + ']';\n            // clear tasks\n            this.tasks = [];\n            return pendingTasksInfo;\n        };\n        ProxyZoneSpec.prototype.onFork = function (parentZoneDelegate, currentZone, targetZone, zoneSpec) {\n            if (this._delegateSpec && this._delegateSpec.onFork) {\n                return this._delegateSpec.onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec);\n            }\n            else {\n                return parentZoneDelegate.fork(targetZone, zoneSpec);\n            }\n        };\n        ProxyZoneSpec.prototype.onIntercept = function (parentZoneDelegate, currentZone, targetZone, delegate, source) {\n            if (this._delegateSpec && this._delegateSpec.onIntercept) {\n                return this._delegateSpec.onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source);\n            }\n            else {\n                return parentZoneDelegate.intercept(targetZone, delegate, source);\n            }\n        };\n        ProxyZoneSpec.prototype.onInvoke = function (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n            this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n            if (this._delegateSpec && this._delegateSpec.onInvoke) {\n                return this._delegateSpec.onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source);\n            }\n            else {\n                return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n            }\n        };\n        ProxyZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n            if (this._delegateSpec && this._delegateSpec.onHandleError) {\n                return this._delegateSpec.onHandleError(parentZoneDelegate, currentZone, targetZone, error);\n            }\n            else {\n                return parentZoneDelegate.handleError(targetZone, error);\n            }\n        };\n        ProxyZoneSpec.prototype.onScheduleTask = function (parentZoneDelegate, currentZone, targetZone, task) {\n            if (task.type !== 'eventTask') {\n                this.tasks.push(task);\n            }\n            if (this._delegateSpec && this._delegateSpec.onScheduleTask) {\n                return this._delegateSpec.onScheduleTask(parentZoneDelegate, currentZone, targetZone, task);\n            }\n            else {\n                return parentZoneDelegate.scheduleTask(targetZone, task);\n            }\n        };\n        ProxyZoneSpec.prototype.onInvokeTask = function (parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) {\n            if (task.type !== 'eventTask') {\n                this.removeFromTasks(task);\n            }\n            this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n            if (this._delegateSpec && this._delegateSpec.onInvokeTask) {\n                return this._delegateSpec.onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs);\n            }\n            else {\n                return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n            }\n        };\n        ProxyZoneSpec.prototype.onCancelTask = function (parentZoneDelegate, currentZone, targetZone, task) {\n            if (task.type !== 'eventTask') {\n                this.removeFromTasks(task);\n            }\n            this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n            if (this._delegateSpec && this._delegateSpec.onCancelTask) {\n                return this._delegateSpec.onCancelTask(parentZoneDelegate, currentZone, targetZone, task);\n            }\n            else {\n                return parentZoneDelegate.cancelTask(targetZone, task);\n            }\n        };\n        ProxyZoneSpec.prototype.onHasTask = function (delegate, current, target, hasTaskState) {\n            this.lastTaskState = hasTaskState;\n            if (this._delegateSpec && this._delegateSpec.onHasTask) {\n                this._delegateSpec.onHasTask(delegate, current, target, hasTaskState);\n            }\n            else {\n                delegate.hasTask(target, hasTaskState);\n            }\n        };\n        return ProxyZoneSpec;\n    }());\n    // Export the class so that new instances can be created with proper\n    // constructor params.\n    Zone['ProxyZoneSpec'] = ProxyZoneSpec;\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var SyncTestZoneSpec = /** @class */ (function () {\n        function SyncTestZoneSpec(namePrefix) {\n            this.runZone = Zone.current;\n            this.name = 'syncTestZone for ' + namePrefix;\n        }\n        SyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n            switch (task.type) {\n                case 'microTask':\n                case 'macroTask':\n                    throw new Error(\"Cannot call \" + task.source + \" from within a sync test.\");\n                case 'eventTask':\n                    task = delegate.scheduleTask(target, task);\n                    break;\n            }\n            return task;\n        };\n        return SyncTestZoneSpec;\n    }());\n    // Export the class so that new instances can be created with proper\n    // constructor params.\n    Zone['SyncTestZoneSpec'] = SyncTestZoneSpec;\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    Zone.__load_patch('jasmine', function (global, Zone, api) {\n        var __extends = function (d, b) {\n            for (var p in b)\n                if (b.hasOwnProperty(p))\n                    d[p] = b[p];\n            function __() { this.constructor = d; }\n            d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());\n        };\n        // Patch jasmine's describe/it/beforeEach/afterEach functions so test code always runs\n        // in a testZone (ProxyZone). (See: angular/zone.js#91 & angular/angular#10503)\n        if (!Zone)\n            throw new Error('Missing: zone.js');\n        if (typeof jest !== 'undefined') {\n            // return if jasmine is a light implementation inside jest\n            // in this case, we are running inside jest not jasmine\n            return;\n        }\n        if (typeof jasmine == 'undefined' || jasmine['__zone_patch__']) {\n            return;\n        }\n        jasmine['__zone_patch__'] = true;\n        var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n        var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        if (!SyncTestZoneSpec)\n            throw new Error('Missing: SyncTestZoneSpec');\n        if (!ProxyZoneSpec)\n            throw new Error('Missing: ProxyZoneSpec');\n        var ambientZone = Zone.current;\n        // Create a synchronous-only zone in which to run `describe` blocks in order to raise an\n        // error if any asynchronous operations are attempted inside of a `describe` but outside of\n        // a `beforeEach` or `it`.\n        var syncZone = ambientZone.fork(new SyncTestZoneSpec('jasmine.describe'));\n        var symbol = Zone.__symbol__;\n        // whether patch jasmine clock when in fakeAsync\n        var disablePatchingJasmineClock = global[symbol('fakeAsyncDisablePatchingClock')] === true;\n        // the original variable name fakeAsyncPatchLock is not accurate, so the name will be\n        // fakeAsyncAutoFakeAsyncWhenClockPatched and if this enablePatchingJasmineClock is false, we also\n        // automatically disable the auto jump into fakeAsync feature\n        var enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock &&\n            ((global[symbol('fakeAsyncPatchLock')] === true) ||\n                (global[symbol('fakeAsyncAutoFakeAsyncWhenClockPatched')] === true));\n        var ignoreUnhandledRejection = global[symbol('ignoreUnhandledRejection')] === true;\n        if (!ignoreUnhandledRejection) {\n            var globalErrors_1 = jasmine.GlobalErrors;\n            if (globalErrors_1 && !jasmine[symbol('GlobalErrors')]) {\n                jasmine[symbol('GlobalErrors')] = globalErrors_1;\n                jasmine.GlobalErrors = function () {\n                    var instance = new globalErrors_1();\n                    var originalInstall = instance.install;\n                    if (originalInstall && !instance[symbol('install')]) {\n                        instance[symbol('install')] = originalInstall;\n                        instance.install = function () {\n                            var originalHandlers = process.listeners('unhandledRejection');\n                            var r = originalInstall.apply(this, arguments);\n                            process.removeAllListeners('unhandledRejection');\n                            if (originalHandlers) {\n                                originalHandlers.forEach(function (h) { return process.on('unhandledRejection', h); });\n                            }\n                            return r;\n                        };\n                    }\n                    return instance;\n                };\n            }\n        }\n        // Monkey patch all of the jasmine DSL so that each function runs in appropriate zone.\n        var jasmineEnv = jasmine.getEnv();\n        ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n            var originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[methodName] = function (description, specDefinitions) {\n                return originalJasmineFn.call(this, description, wrapDescribeInZone(specDefinitions));\n            };\n        });\n        ['it', 'xit', 'fit'].forEach(function (methodName) {\n            var originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[symbol(methodName)] = originalJasmineFn;\n            jasmineEnv[methodName] = function (description, specDefinitions, timeout) {\n                arguments[1] = wrapTestInZone(specDefinitions);\n                return originalJasmineFn.apply(this, arguments);\n            };\n        });\n        ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n            var originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[symbol(methodName)] = originalJasmineFn;\n            jasmineEnv[methodName] = function (specDefinitions, timeout) {\n                arguments[0] = wrapTestInZone(specDefinitions);\n                return originalJasmineFn.apply(this, arguments);\n            };\n        });\n        if (!disablePatchingJasmineClock) {\n            // need to patch jasmine.clock().mockDate and jasmine.clock().tick() so\n            // they can work properly in FakeAsyncTest\n            var originalClockFn_1 = (jasmine[symbol('clock')] = jasmine['clock']);\n            jasmine['clock'] = function () {\n                var clock = originalClockFn_1.apply(this, arguments);\n                if (!clock[symbol('patched')]) {\n                    clock[symbol('patched')] = symbol('patched');\n                    var originalTick_1 = (clock[symbol('tick')] = clock.tick);\n                    clock.tick = function () {\n                        var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                        if (fakeAsyncZoneSpec) {\n                            return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);\n                        }\n                        return originalTick_1.apply(this, arguments);\n                    };\n                    var originalMockDate_1 = (clock[symbol('mockDate')] = clock.mockDate);\n                    clock.mockDate = function () {\n                        var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                        if (fakeAsyncZoneSpec) {\n                            var dateTime = arguments.length > 0 ? arguments[0] : new Date();\n                            return fakeAsyncZoneSpec.setCurrentRealTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === 'function' ?\n                                [dateTime.getTime()] :\n                                arguments);\n                        }\n                        return originalMockDate_1.apply(this, arguments);\n                    };\n                    // for auto go into fakeAsync feature, we need the flag to enable it\n                    if (enableAutoFakeAsyncWhenClockPatched) {\n                        ['install', 'uninstall'].forEach(function (methodName) {\n                            var originalClockFn = (clock[symbol(methodName)] = clock[methodName]);\n                            clock[methodName] = function () {\n                                var FakeAsyncTestZoneSpec = Zone['FakeAsyncTestZoneSpec'];\n                                if (FakeAsyncTestZoneSpec) {\n                                    jasmine[symbol('clockInstalled')] = 'install' === methodName;\n                                    return;\n                                }\n                                return originalClockFn.apply(this, arguments);\n                            };\n                        });\n                    }\n                }\n                return clock;\n            };\n        }\n        /**\n         * Gets a function wrapping the body of a Jasmine `describe` block to execute in a\n         * synchronous-only zone.\n         */\n        function wrapDescribeInZone(describeBody) {\n            return function () {\n                return syncZone.run(describeBody, this, arguments);\n            };\n        }\n        function runInTestZone(testBody, applyThis, queueRunner, done) {\n            var isClockInstalled = !!jasmine[symbol('clockInstalled')];\n            var testProxyZoneSpec = queueRunner.testProxyZoneSpec;\n            var testProxyZone = queueRunner.testProxyZone;\n            if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {\n                // auto run a fakeAsync\n                var fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n                if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n                    testBody = fakeAsyncModule.fakeAsync(testBody);\n                }\n            }\n            if (done) {\n                return testProxyZone.run(testBody, applyThis, [done]);\n            }\n            else {\n                return testProxyZone.run(testBody, applyThis);\n            }\n        }\n        /**\n         * Gets a function wrapping the body of a Jasmine `it/beforeEach/afterEach` block to\n         * execute in a ProxyZone zone.\n         * This will run in `testProxyZone`. The `testProxyZone` will be reset by the `ZoneQueueRunner`\n         */\n        function wrapTestInZone(testBody) {\n            // The `done` callback is only passed through if the function expects at least one argument.\n            // Note we have to make a function with correct number of arguments, otherwise jasmine will\n            // think that all functions are sync or async.\n            return (testBody && (testBody.length ? function (done) {\n                return runInTestZone(testBody, this, this.queueRunner, done);\n            } : function () {\n                return runInTestZone(testBody, this, this.queueRunner);\n            }));\n        }\n        var QueueRunner = jasmine.QueueRunner;\n        jasmine.QueueRunner = (function (_super) {\n            __extends(ZoneQueueRunner, _super);\n            function ZoneQueueRunner(attrs) {\n                var _this = this;\n                if (attrs.onComplete) {\n                    attrs.onComplete = (function (fn) { return function () {\n                        // All functions are done, clear the test zone.\n                        _this.testProxyZone = null;\n                        _this.testProxyZoneSpec = null;\n                        ambientZone.scheduleMicroTask('jasmine.onComplete', fn);\n                    }; })(attrs.onComplete);\n                }\n                var nativeSetTimeout = global[Zone.__symbol__('setTimeout')];\n                var nativeClearTimeout = global[Zone.__symbol__('clearTimeout')];\n                if (nativeSetTimeout) {\n                    // should run setTimeout inside jasmine outside of zone\n                    attrs.timeout = {\n                        setTimeout: nativeSetTimeout ? nativeSetTimeout : global.setTimeout,\n                        clearTimeout: nativeClearTimeout ? nativeClearTimeout : global.clearTimeout\n                    };\n                }\n                // create a userContext to hold the queueRunner itself\n                // so we can access the testProxy in it/xit/beforeEach ...\n                if (jasmine.UserContext) {\n                    if (!attrs.userContext) {\n                        attrs.userContext = new jasmine.UserContext();\n                    }\n                    attrs.userContext.queueRunner = this;\n                }\n                else {\n                    if (!attrs.userContext) {\n                        attrs.userContext = {};\n                    }\n                    attrs.userContext.queueRunner = this;\n                }\n                // patch attrs.onException\n                var onException = attrs.onException;\n                attrs.onException = function (error) {\n                    if (error &&\n                        error.message ===\n                            'Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.') {\n                        // jasmine timeout, we can make the error message more\n                        // reasonable to tell what tasks are pending\n                        var proxyZoneSpec = this && this.testProxyZoneSpec;\n                        if (proxyZoneSpec) {\n                            var pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();\n                            try {\n                                // try catch here in case error.message is not writable\n                                error.message += pendingTasksInfo;\n                            }\n                            catch (err) {\n                            }\n                        }\n                    }\n                    if (onException) {\n                        onException.call(this, error);\n                    }\n                };\n                _super.call(this, attrs);\n            }\n            ZoneQueueRunner.prototype.execute = function () {\n                var _this = this;\n                var zone = Zone.current;\n                var isChildOfAmbientZone = false;\n                while (zone) {\n                    if (zone === ambientZone) {\n                        isChildOfAmbientZone = true;\n                        break;\n                    }\n                    zone = zone.parent;\n                }\n                if (!isChildOfAmbientZone)\n                    throw new Error('Unexpected Zone: ' + Zone.current.name);\n                // This is the zone which will be used for running individual tests.\n                // It will be a proxy zone, so that the tests function can retroactively install\n                // different zones.\n                // Example:\n                //   - In beforeEach() do childZone = Zone.current.fork(...);\n                //   - In it() try to do fakeAsync(). The issue is that because the beforeEach forked the\n                //     zone outside of fakeAsync it will be able to escape the fakeAsync rules.\n                //   - Because ProxyZone is parent fo `childZone` fakeAsync can retroactively add\n                //     fakeAsync behavior to the childZone.\n                this.testProxyZoneSpec = new ProxyZoneSpec();\n                this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);\n                if (!Zone.currentTask) {\n                    // if we are not running in a task then if someone would register a\n                    // element.addEventListener and then calling element.click() the\n                    // addEventListener callback would think that it is the top most task and would\n                    // drain the microtask queue on element.click() which would be incorrect.\n                    // For this reason we always force a task when running jasmine tests.\n                    Zone.current.scheduleMicroTask('jasmine.execute().forceTask', function () { return QueueRunner.prototype.execute.call(_this); });\n                }\n                else {\n                    _super.prototype.execute.call(this);\n                }\n            };\n            return ZoneQueueRunner;\n        })(QueueRunner);\n    });\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    Zone.__load_patch('jest', function (context, Zone) {\n        if (typeof jest === 'undefined' || jest['__zone_patch__']) {\n            return;\n        }\n        jest['__zone_patch__'] = true;\n        if (typeof Zone === 'undefined') {\n            throw new Error('Missing Zone.js');\n        }\n        var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n        if (!ProxyZoneSpec) {\n            throw new Error('Missing ProxyZoneSpec');\n        }\n        var rootZone = Zone.current;\n        var syncZone = rootZone.fork(new SyncTestZoneSpec('jest.describe'));\n        var proxyZone = rootZone.fork(new ProxyZoneSpec());\n        function wrapDescribeFactoryInZone(originalJestFn) {\n            return function () {\n                var tableArgs = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    tableArgs[_i] = arguments[_i];\n                }\n                var originalDescribeFn = originalJestFn.apply(this, tableArgs);\n                return function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    args[1] = wrapDescribeInZone(args[1]);\n                    return originalDescribeFn.apply(this, args);\n                };\n            };\n        }\n        function wrapTestFactoryInZone(originalJestFn) {\n            return function () {\n                var tableArgs = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    tableArgs[_i] = arguments[_i];\n                }\n                var testFn = originalJestFn.apply(this, tableArgs);\n                return function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    args[1] = wrapTestInZone(args[1]);\n                    return testFn.apply(this, args);\n                };\n            };\n        }\n        /**\n         * Gets a function wrapping the body of a jest `describe` block to execute in a\n         * synchronous-only zone.\n         */\n        function wrapDescribeInZone(describeBody) {\n            return function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                return syncZone.run(describeBody, this, args);\n            };\n        }\n        /**\n         * Gets a function wrapping the body of a jest `it/beforeEach/afterEach` block to\n         * execute in a ProxyZone zone.\n         * This will run in the `testProxyZone`.\n         */\n        function wrapTestInZone(testBody) {\n            if (typeof testBody !== 'function') {\n                return testBody;\n            }\n            // The `done` callback is only passed through if the function expects at least one argument.\n            // Note we have to make a function with correct number of arguments, otherwise jest will\n            // think that all functions are sync or async.\n            return function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                return proxyZone.run(testBody, this, args);\n            };\n        }\n        ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n            var originalJestFn = context[methodName];\n            if (context[Zone.__symbol__(methodName)]) {\n                return;\n            }\n            context[Zone.__symbol__(methodName)] = originalJestFn;\n            context[methodName] = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                args[1] = wrapDescribeInZone(args[1]);\n                return originalJestFn.apply(this, args);\n            };\n            context[methodName].each = wrapDescribeFactoryInZone(originalJestFn.each);\n        });\n        context.describe.only = context.fdescribe;\n        context.describe.skip = context.xdescribe;\n        ['it', 'xit', 'fit', 'test', 'xtest'].forEach(function (methodName) {\n            var originalJestFn = context[methodName];\n            if (context[Zone.__symbol__(methodName)]) {\n                return;\n            }\n            context[Zone.__symbol__(methodName)] = originalJestFn;\n            context[methodName] = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                args[1] = wrapTestInZone(args[1]);\n                return originalJestFn.apply(this, args);\n            };\n            context[methodName].each = wrapTestFactoryInZone(originalJestFn.each);\n            context[methodName].todo = originalJestFn.todo;\n        });\n        context.it.only = context.fit;\n        context.it.skip = context.xit;\n        context.test.only = context.fit;\n        context.test.skip = context.xit;\n        ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n            var originalJestFn = context[methodName];\n            if (context[Zone.__symbol__(methodName)]) {\n                return;\n            }\n            context[Zone.__symbol__(methodName)] = originalJestFn;\n            context[methodName] = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                args[0] = wrapTestInZone(args[0]);\n                return originalJestFn.apply(this, args);\n            };\n        });\n    });\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    Zone.__load_patch('mocha', function (global, Zone) {\n        var Mocha = global.Mocha;\n        if (typeof Mocha === 'undefined') {\n            // return if Mocha is not available, because now zone-testing\n            // will load mocha patch with jasmine/jest patch\n            return;\n        }\n        if (typeof Zone === 'undefined') {\n            throw new Error('Missing Zone.js');\n        }\n        var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n        if (!ProxyZoneSpec) {\n            throw new Error('Missing ProxyZoneSpec');\n        }\n        if (Mocha['__zone_patch__']) {\n            throw new Error('\"Mocha\" has already been patched with \"Zone\".');\n        }\n        Mocha['__zone_patch__'] = true;\n        var rootZone = Zone.current;\n        var syncZone = rootZone.fork(new SyncTestZoneSpec('Mocha.describe'));\n        var testZone = null;\n        var suiteZone = rootZone.fork(new ProxyZoneSpec());\n        var mochaOriginal = {\n            after: Mocha.after,\n            afterEach: Mocha.afterEach,\n            before: Mocha.before,\n            beforeEach: Mocha.beforeEach,\n            describe: Mocha.describe,\n            it: Mocha.it\n        };\n        function modifyArguments(args, syncTest, asyncTest) {\n            var _loop_1 = function (i) {\n                var arg = args[i];\n                if (typeof arg === 'function') {\n                    // The `done` callback is only passed through if the function expects at\n                    // least one argument.\n                    // Note we have to make a function with correct number of arguments,\n                    // otherwise mocha will\n                    // think that all functions are sync or async.\n                    args[i] = (arg.length === 0) ? syncTest(arg) : asyncTest(arg);\n                    // Mocha uses toString to view the test body in the result list, make sure we return the\n                    // correct function body\n                    args[i].toString = function () { return arg.toString(); };\n                }\n            };\n            for (var i = 0; i < args.length; i++) {\n                _loop_1(i);\n            }\n            return args;\n        }\n        function wrapDescribeInZone(args) {\n            var syncTest = function (fn) {\n                return function () { return syncZone.run(fn, this, arguments); };\n            };\n            return modifyArguments(args, syncTest);\n        }\n        function wrapTestInZone(args) {\n            var asyncTest = function (fn) {\n                return function (done) { return testZone.run(fn, this, [done]); };\n            };\n            var syncTest = function (fn) {\n                return function () { return testZone.run(fn, this); };\n            };\n            return modifyArguments(args, syncTest, asyncTest);\n        }\n        function wrapSuiteInZone(args) {\n            var asyncTest = function (fn) {\n                return function (done) { return suiteZone.run(fn, this, [done]); };\n            };\n            var syncTest = function (fn) {\n                return function () { return suiteZone.run(fn, this); };\n            };\n            return modifyArguments(args, syncTest, asyncTest);\n        }\n        global.describe = global.suite = Mocha.describe = function () {\n            return mochaOriginal.describe.apply(this, wrapDescribeInZone(arguments));\n        };\n        global.xdescribe = global.suite.skip = Mocha.describe.skip = function () {\n            return mochaOriginal.describe.skip.apply(this, wrapDescribeInZone(arguments));\n        };\n        global.describe.only = global.suite.only = Mocha.describe.only = function () {\n            return mochaOriginal.describe.only.apply(this, wrapDescribeInZone(arguments));\n        };\n        global.it = global.specify = global.test =\n            Mocha.it = function () { return mochaOriginal.it.apply(this, wrapTestInZone(arguments)); };\n        global.xit = global.xspecify = Mocha.it.skip = function () {\n            return mochaOriginal.it.skip.apply(this, wrapTestInZone(arguments));\n        };\n        global.it.only = global.test.only = Mocha.it.only = function () {\n            return mochaOriginal.it.only.apply(this, wrapTestInZone(arguments));\n        };\n        global.after = global.suiteTeardown = Mocha.after = function () {\n            return mochaOriginal.after.apply(this, wrapSuiteInZone(arguments));\n        };\n        global.afterEach = global.teardown = Mocha.afterEach = function () {\n            return mochaOriginal.afterEach.apply(this, wrapTestInZone(arguments));\n        };\n        global.before = global.suiteSetup = Mocha.before = function () {\n            return mochaOriginal.before.apply(this, wrapSuiteInZone(arguments));\n        };\n        global.beforeEach = global.setup = Mocha.beforeEach = function () {\n            return mochaOriginal.beforeEach.apply(this, wrapTestInZone(arguments));\n        };\n        (function (originalRunTest, originalRun) {\n            Mocha.Runner.prototype.runTest = function (fn) {\n                var _this = this;\n                Zone.current.scheduleMicroTask('mocha.forceTask', function () { originalRunTest.call(_this, fn); });\n            };\n            Mocha.Runner.prototype.run = function (fn) {\n                this.on('test', function (e) { testZone = rootZone.fork(new ProxyZoneSpec()); });\n                this.on('fail', function (test, err) {\n                    var proxyZoneSpec = testZone && testZone.get('ProxyZoneSpec');\n                    if (proxyZoneSpec && err) {\n                        try {\n                            // try catch here in case err.message is not writable\n                            err.message += proxyZoneSpec.getAndClearPendingTasksInfo();\n                        }\n                        catch (error) {\n                        }\n                    }\n                });\n                return originalRun.call(this, fn);\n            };\n        })(Mocha.Runner.prototype.runTest, Mocha.Runner.prototype.run);\n    });\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    (function (_global) {\n        var AsyncTestZoneSpec = /** @class */ (function () {\n            function AsyncTestZoneSpec(finishCallback, failCallback, namePrefix) {\n                this.finishCallback = finishCallback;\n                this.failCallback = failCallback;\n                this._pendingMicroTasks = false;\n                this._pendingMacroTasks = false;\n                this._alreadyErrored = false;\n                this._isSync = false;\n                this.runZone = Zone.current;\n                this.unresolvedChainedPromiseCount = 0;\n                this.supportWaitUnresolvedChainedPromise = false;\n                this.name = 'asyncTestZone for ' + namePrefix;\n                this.properties = { 'AsyncTestZoneSpec': this };\n                this.supportWaitUnresolvedChainedPromise =\n                    _global[Zone.__symbol__('supportWaitUnResolvedChainedPromise')] === true;\n            }\n            AsyncTestZoneSpec.prototype.isUnresolvedChainedPromisePending = function () { return this.unresolvedChainedPromiseCount > 0; };\n            AsyncTestZoneSpec.prototype._finishCallbackIfDone = function () {\n                var _this = this;\n                if (!(this._pendingMicroTasks || this._pendingMacroTasks ||\n                    (this.supportWaitUnresolvedChainedPromise &&\n                        this.isUnresolvedChainedPromisePending()))) {\n                    // We do this because we would like to catch unhandled rejected promises.\n                    this.runZone.run(function () {\n                        setTimeout(function () {\n                            if (!_this._alreadyErrored && !(_this._pendingMicroTasks || _this._pendingMacroTasks)) {\n                                _this.finishCallback();\n                            }\n                        }, 0);\n                    });\n                }\n            };\n            AsyncTestZoneSpec.prototype.patchPromiseForTest = function () {\n                if (!this.supportWaitUnresolvedChainedPromise) {\n                    return;\n                }\n                var patchPromiseForTest = Promise[Zone.__symbol__('patchPromiseForTest')];\n                if (patchPromiseForTest) {\n                    patchPromiseForTest();\n                }\n            };\n            AsyncTestZoneSpec.prototype.unPatchPromiseForTest = function () {\n                if (!this.supportWaitUnresolvedChainedPromise) {\n                    return;\n                }\n                var unPatchPromiseForTest = Promise[Zone.__symbol__('unPatchPromiseForTest')];\n                if (unPatchPromiseForTest) {\n                    unPatchPromiseForTest();\n                }\n            };\n            AsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n                if (task.type !== 'eventTask') {\n                    this._isSync = false;\n                }\n                if (task.type === 'microTask' && task.data && task.data instanceof Promise) {\n                    // check whether the promise is a chained promise\n                    if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {\n                        // chained promise is being scheduled\n                        this.unresolvedChainedPromiseCount--;\n                    }\n                }\n                return delegate.scheduleTask(target, task);\n            };\n            AsyncTestZoneSpec.prototype.onInvokeTask = function (delegate, current, target, task, applyThis, applyArgs) {\n                if (task.type !== 'eventTask') {\n                    this._isSync = false;\n                }\n                return delegate.invokeTask(target, task, applyThis, applyArgs);\n            };\n            AsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n                if (task.type !== 'eventTask') {\n                    this._isSync = false;\n                }\n                return delegate.cancelTask(target, task);\n            };\n            // Note - we need to use onInvoke at the moment to call finish when a test is\n            // fully synchronous. TODO(juliemr): remove this when the logic for\n            // onHasTask changes and it calls whenever the task queues are dirty.\n            // updated by(JiaLiPassion), only call finish callback when no task\n            // was scheduled/invoked/canceled.\n            AsyncTestZoneSpec.prototype.onInvoke = function (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n                try {\n                    this._isSync = true;\n                    return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n                }\n                finally {\n                    var afterTaskCounts = parentZoneDelegate._taskCounts;\n                    if (this._isSync) {\n                        this._finishCallbackIfDone();\n                    }\n                }\n            };\n            AsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n                // Let the parent try to handle the error.\n                var result = parentZoneDelegate.handleError(targetZone, error);\n                if (result) {\n                    this.failCallback(error);\n                    this._alreadyErrored = true;\n                }\n                return false;\n            };\n            AsyncTestZoneSpec.prototype.onHasTask = function (delegate, current, target, hasTaskState) {\n                delegate.hasTask(target, hasTaskState);\n                if (hasTaskState.change == 'microTask') {\n                    this._pendingMicroTasks = hasTaskState.microTask;\n                    this._finishCallbackIfDone();\n                }\n                else if (hasTaskState.change == 'macroTask') {\n                    this._pendingMacroTasks = hasTaskState.macroTask;\n                    this._finishCallbackIfDone();\n                }\n            };\n            return AsyncTestZoneSpec;\n        }());\n        AsyncTestZoneSpec.symbolParentUnresolved = Zone.__symbol__('parentUnresolved');\n        // Export the class so that new instances can be created with proper\n        // constructor params.\n        Zone['AsyncTestZoneSpec'] = AsyncTestZoneSpec;\n    })(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    Zone.__load_patch('asynctest', function (global, Zone, api) {\n        /**\n         * Wraps a test function in an asynchronous test zone. The test will automatically\n         * complete when all asynchronous calls within this zone are done.\n         */\n        Zone[api.symbol('asyncTest')] = function asyncTest(fn) {\n            // If we're running using the Jasmine test framework, adapt to call the 'done'\n            // function when asynchronous activity is finished.\n            if (global.jasmine) {\n                // Not using an arrow function to preserve context passed from call site\n                return function (done) {\n                    if (!done) {\n                        // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n                        // fake it here and assume sync.\n                        done = function () { };\n                        done.fail = function (e) { throw e; };\n                    }\n                    runInTestZone(fn, this, done, function (err) {\n                        if (typeof err === 'string') {\n                            return done.fail(new Error(err));\n                        }\n                        else {\n                            done.fail(err);\n                        }\n                    });\n                };\n            }\n            // Otherwise, return a promise which will resolve when asynchronous activity\n            // is finished. This will be correctly consumed by the Mocha framework with\n            // it('...', async(myFn)); or can be used in a custom framework.\n            // Not using an arrow function to preserve context passed from call site\n            return function () {\n                var _this = this;\n                return new Promise(function (finishCallback, failCallback) {\n                    runInTestZone(fn, _this, finishCallback, failCallback);\n                });\n            };\n        };\n        function runInTestZone(fn, context, finishCallback, failCallback) {\n            var currentZone = Zone.current;\n            var AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n            if (AsyncTestZoneSpec === undefined) {\n                throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' +\n                    'Please make sure that your environment includes zone.js/dist/async-test.js');\n            }\n            var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n            if (ProxyZoneSpec === undefined) {\n                throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n                    'Please make sure that your environment includes zone.js/dist/proxy.js');\n            }\n            var proxyZoneSpec = ProxyZoneSpec.get();\n            ProxyZoneSpec.assertPresent();\n            // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n            // If we do it in ProxyZone then we will get to infinite recursion.\n            var proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n            var previousDelegate = proxyZoneSpec.getDelegate();\n            proxyZone.parent.run(function () {\n                var testZoneSpec = new AsyncTestZoneSpec(function () {\n                    // Need to restore the original zone.\n                    if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                        // Only reset the zone spec if it's\n                        // sill this one. Otherwise, assume\n                        // it's OK.\n                        proxyZoneSpec.setDelegate(previousDelegate);\n                    }\n                    testZoneSpec.unPatchPromiseForTest();\n                    currentZone.run(function () { finishCallback(); });\n                }, function (error) {\n                    // Need to restore the original zone.\n                    if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                        // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n                        proxyZoneSpec.setDelegate(previousDelegate);\n                    }\n                    testZoneSpec.unPatchPromiseForTest();\n                    currentZone.run(function () { failCallback(error); });\n                }, 'test');\n                proxyZoneSpec.setDelegate(testZoneSpec);\n                testZoneSpec.patchPromiseForTest();\n            });\n            return Zone.current.runGuarded(fn, context);\n        }\n    });\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    (function (global) {\n        var OriginalDate = global.Date;\n        var FakeDate = /** @class */ (function () {\n            function FakeDate() {\n                if (arguments.length === 0) {\n                    var d = new OriginalDate();\n                    d.setTime(FakeDate.now());\n                    return d;\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments);\n                    return new (OriginalDate.bind.apply(OriginalDate, __spreadArrays([void 0], args)))();\n                }\n            }\n            FakeDate.now = function () {\n                var fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (fakeAsyncTestZoneSpec) {\n                    return fakeAsyncTestZoneSpec.getCurrentRealTime() + fakeAsyncTestZoneSpec.getCurrentTime();\n                }\n                return OriginalDate.now.apply(this, arguments);\n            };\n            return FakeDate;\n        }());\n        FakeDate.UTC = OriginalDate.UTC;\n        FakeDate.parse = OriginalDate.parse;\n        // keep a reference for zone patched timer function\n        var timers = {\n            setTimeout: global.setTimeout,\n            setInterval: global.setInterval,\n            clearTimeout: global.clearTimeout,\n            clearInterval: global.clearInterval\n        };\n        var Scheduler = /** @class */ (function () {\n            function Scheduler() {\n                // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n                this._schedulerQueue = [];\n                // Current simulated time in millis.\n                this._currentTime = 0;\n                // Current real time in millis.\n                this._currentRealTime = OriginalDate.now();\n                // track requeuePeriodicTimer\n                this._currentTickRequeuePeriodicEntries = [];\n            }\n            Scheduler.prototype.getCurrentTime = function () { return this._currentTime; };\n            Scheduler.prototype.getCurrentRealTime = function () { return this._currentRealTime; };\n            Scheduler.prototype.setCurrentRealTime = function (realTime) { this._currentRealTime = realTime; };\n            Scheduler.prototype.scheduleFunction = function (cb, delay, options) {\n                options = Object.assign({\n                    args: [],\n                    isPeriodic: false,\n                    isRequestAnimationFrame: false,\n                    id: -1,\n                    isRequeuePeriodic: false\n                }, options);\n                var currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n                var endTime = this._currentTime + delay;\n                // Insert so that scheduler queue remains sorted by end time.\n                var newEntry = {\n                    endTime: endTime,\n                    id: currentId,\n                    func: cb,\n                    args: options.args,\n                    delay: delay,\n                    isPeriodic: options.isPeriodic,\n                    isRequestAnimationFrame: options.isRequestAnimationFrame\n                };\n                if (options.isRequeuePeriodic) {\n                    this._currentTickRequeuePeriodicEntries.push(newEntry);\n                }\n                var i = 0;\n                for (; i < this._schedulerQueue.length; i++) {\n                    var currentEntry = this._schedulerQueue[i];\n                    if (newEntry.endTime < currentEntry.endTime) {\n                        break;\n                    }\n                }\n                this._schedulerQueue.splice(i, 0, newEntry);\n                return currentId;\n            };\n            Scheduler.prototype.removeScheduledFunctionWithId = function (id) {\n                for (var i = 0; i < this._schedulerQueue.length; i++) {\n                    if (this._schedulerQueue[i].id == id) {\n                        this._schedulerQueue.splice(i, 1);\n                        break;\n                    }\n                }\n            };\n            Scheduler.prototype.tick = function (millis, doTick, tickOptions) {\n                if (millis === void 0) { millis = 0; }\n                var finalTime = this._currentTime + millis;\n                var lastCurrentTime = 0;\n                tickOptions = Object.assign({ processNewMacroTasksSynchronously: true }, tickOptions);\n                // we need to copy the schedulerQueue so nested timeout\n                // will not be wrongly called in the current tick\n                // https://github.com/angular/angular/issues/33799\n                var schedulerQueue = tickOptions.processNewMacroTasksSynchronously ?\n                    this._schedulerQueue :\n                    this._schedulerQueue.slice();\n                if (schedulerQueue.length === 0 && doTick) {\n                    doTick(millis);\n                    return;\n                }\n                while (schedulerQueue.length > 0) {\n                    // clear requeueEntries before each loop\n                    this._currentTickRequeuePeriodicEntries = [];\n                    var current = schedulerQueue[0];\n                    if (finalTime < current.endTime) {\n                        // Done processing the queue since it's sorted by endTime.\n                        break;\n                    }\n                    else {\n                        // Time to run scheduled function. Remove it from the head of queue.\n                        var current_1 = schedulerQueue.shift();\n                        if (!tickOptions.processNewMacroTasksSynchronously) {\n                            var idx = this._schedulerQueue.indexOf(current_1);\n                            if (idx >= 0) {\n                                this._schedulerQueue.splice(idx, 1);\n                            }\n                        }\n                        lastCurrentTime = this._currentTime;\n                        this._currentTime = current_1.endTime;\n                        if (doTick) {\n                            doTick(this._currentTime - lastCurrentTime);\n                        }\n                        var retval = current_1.func.apply(global, current_1.isRequestAnimationFrame ? [this._currentTime] : current_1.args);\n                        if (!retval) {\n                            // Uncaught exception in the current scheduled function. Stop processing the queue.\n                            break;\n                        }\n                        // check is there any requeue periodic entry is added in\n                        // current loop, if there is, we need to add to current loop\n                        if (!tickOptions.processNewMacroTasksSynchronously) {\n                            this._currentTickRequeuePeriodicEntries.forEach(function (newEntry) {\n                                var i = 0;\n                                for (; i < schedulerQueue.length; i++) {\n                                    var currentEntry = schedulerQueue[i];\n                                    if (newEntry.endTime < currentEntry.endTime) {\n                                        break;\n                                    }\n                                }\n                                schedulerQueue.splice(i, 0, newEntry);\n                            });\n                        }\n                    }\n                }\n                lastCurrentTime = this._currentTime;\n                this._currentTime = finalTime;\n                if (doTick) {\n                    doTick(this._currentTime - lastCurrentTime);\n                }\n            };\n            Scheduler.prototype.flush = function (limit, flushPeriodic, doTick) {\n                if (limit === void 0) { limit = 20; }\n                if (flushPeriodic === void 0) { flushPeriodic = false; }\n                if (flushPeriodic) {\n                    return this.flushPeriodic(doTick);\n                }\n                else {\n                    return this.flushNonPeriodic(limit, doTick);\n                }\n            };\n            Scheduler.prototype.flushPeriodic = function (doTick) {\n                if (this._schedulerQueue.length === 0) {\n                    return 0;\n                }\n                // Find the last task currently queued in the scheduler queue and tick\n                // till that time.\n                var startTime = this._currentTime;\n                var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n                this.tick(lastTask.endTime - startTime, doTick);\n                return this._currentTime - startTime;\n            };\n            Scheduler.prototype.flushNonPeriodic = function (limit, doTick) {\n                var startTime = this._currentTime;\n                var lastCurrentTime = 0;\n                var count = 0;\n                while (this._schedulerQueue.length > 0) {\n                    count++;\n                    if (count > limit) {\n                        throw new Error('flush failed after reaching the limit of ' + limit +\n                            ' tasks. Does your code use a polling timeout?');\n                    }\n                    // flush only non-periodic timers.\n                    // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n                    if (this._schedulerQueue.filter(function (task) { return !task.isPeriodic && !task.isRequestAnimationFrame; })\n                        .length === 0) {\n                        break;\n                    }\n                    var current = this._schedulerQueue.shift();\n                    lastCurrentTime = this._currentTime;\n                    this._currentTime = current.endTime;\n                    if (doTick) {\n                        // Update any secondary schedulers like Jasmine mock Date.\n                        doTick(this._currentTime - lastCurrentTime);\n                    }\n                    var retval = current.func.apply(global, current.args);\n                    if (!retval) {\n                        // Uncaught exception in the current scheduled function. Stop processing the queue.\n                        break;\n                    }\n                }\n                return this._currentTime - startTime;\n            };\n            return Scheduler;\n        }());\n        // Next scheduler id.\n        Scheduler.nextId = 1;\n        var FakeAsyncTestZoneSpec = /** @class */ (function () {\n            function FakeAsyncTestZoneSpec(namePrefix, trackPendingRequestAnimationFrame, macroTaskOptions) {\n                if (trackPendingRequestAnimationFrame === void 0) { trackPendingRequestAnimationFrame = false; }\n                this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n                this.macroTaskOptions = macroTaskOptions;\n                this._scheduler = new Scheduler();\n                this._microtasks = [];\n                this._lastError = null;\n                this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n                this.pendingPeriodicTimers = [];\n                this.pendingTimers = [];\n                this.patchDateLocked = false;\n                this.properties = { 'FakeAsyncTestZoneSpec': this };\n                this.name = 'fakeAsyncTestZone for ' + namePrefix;\n                // in case user can't access the construction of FakeAsyncTestSpec\n                // user can also define macroTaskOptions by define a global variable.\n                if (!this.macroTaskOptions) {\n                    this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n                }\n            }\n            FakeAsyncTestZoneSpec.assertInZone = function () {\n                if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n                    throw new Error('The code should be running in the fakeAsync zone to call this function');\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype._fnAndFlush = function (fn, completers) {\n                var _this = this;\n                return function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    fn.apply(global, args);\n                    if (_this._lastError === null) { // Success\n                        if (completers.onSuccess != null) {\n                            completers.onSuccess.apply(global);\n                        }\n                        // Flush microtasks only on success.\n                        _this.flushMicrotasks();\n                    }\n                    else { // Failure\n                        if (completers.onError != null) {\n                            completers.onError.apply(global);\n                        }\n                    }\n                    // Return true if there were no errors, false otherwise.\n                    return _this._lastError === null;\n                };\n            };\n            FakeAsyncTestZoneSpec._removeTimer = function (timers, id) {\n                var index = timers.indexOf(id);\n                if (index > -1) {\n                    timers.splice(index, 1);\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype._dequeueTimer = function (id) {\n                var _this = this;\n                return function () { FakeAsyncTestZoneSpec._removeTimer(_this.pendingTimers, id); };\n            };\n            FakeAsyncTestZoneSpec.prototype._requeuePeriodicTimer = function (fn, interval, args, id) {\n                var _this = this;\n                return function () {\n                    // Requeue the timer callback if it's not been canceled.\n                    if (_this.pendingPeriodicTimers.indexOf(id) !== -1) {\n                        _this._scheduler.scheduleFunction(fn, interval, { args: args, isPeriodic: true, id: id, isRequeuePeriodic: true });\n                    }\n                };\n            };\n            FakeAsyncTestZoneSpec.prototype._dequeuePeriodicTimer = function (id) {\n                var _this = this;\n                return function () { FakeAsyncTestZoneSpec._removeTimer(_this.pendingPeriodicTimers, id); };\n            };\n            FakeAsyncTestZoneSpec.prototype._setTimeout = function (fn, delay, args, isTimer) {\n                if (isTimer === void 0) { isTimer = true; }\n                var removeTimerFn = this._dequeueTimer(Scheduler.nextId);\n                // Queue the callback and dequeue the timer on success and error.\n                var cb = this._fnAndFlush(fn, { onSuccess: removeTimerFn, onError: removeTimerFn });\n                var id = this._scheduler.scheduleFunction(cb, delay, { args: args, isRequestAnimationFrame: !isTimer });\n                if (isTimer) {\n                    this.pendingTimers.push(id);\n                }\n                return id;\n            };\n            FakeAsyncTestZoneSpec.prototype._clearTimeout = function (id) {\n                FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n                this._scheduler.removeScheduledFunctionWithId(id);\n            };\n            FakeAsyncTestZoneSpec.prototype._setInterval = function (fn, interval, args) {\n                var id = Scheduler.nextId;\n                var completers = { onSuccess: null, onError: this._dequeuePeriodicTimer(id) };\n                var cb = this._fnAndFlush(fn, completers);\n                // Use the callback created above to requeue on success.\n                completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id);\n                // Queue the callback and dequeue the periodic timer only on error.\n                this._scheduler.scheduleFunction(cb, interval, { args: args, isPeriodic: true });\n                this.pendingPeriodicTimers.push(id);\n                return id;\n            };\n            FakeAsyncTestZoneSpec.prototype._clearInterval = function (id) {\n                FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n                this._scheduler.removeScheduledFunctionWithId(id);\n            };\n            FakeAsyncTestZoneSpec.prototype._resetLastErrorAndThrow = function () {\n                var error = this._lastError || this._uncaughtPromiseErrors[0];\n                this._uncaughtPromiseErrors.length = 0;\n                this._lastError = null;\n                throw error;\n            };\n            FakeAsyncTestZoneSpec.prototype.getCurrentTime = function () { return this._scheduler.getCurrentTime(); };\n            FakeAsyncTestZoneSpec.prototype.getCurrentRealTime = function () { return this._scheduler.getCurrentRealTime(); };\n            FakeAsyncTestZoneSpec.prototype.setCurrentRealTime = function (realTime) { this._scheduler.setCurrentRealTime(realTime); };\n            FakeAsyncTestZoneSpec.patchDate = function () {\n                if (!!global[Zone.__symbol__('disableDatePatching')]) {\n                    // we don't want to patch global Date\n                    // because in some case, global Date\n                    // is already being patched, we need to provide\n                    // an option to let user still use their\n                    // own version of Date.\n                    return;\n                }\n                if (global['Date'] === FakeDate) {\n                    // already patched\n                    return;\n                }\n                global['Date'] = FakeDate;\n                FakeDate.prototype = OriginalDate.prototype;\n                // try check and reset timers\n                // because jasmine.clock().install() may\n                // have replaced the global timer\n                FakeAsyncTestZoneSpec.checkTimerPatch();\n            };\n            FakeAsyncTestZoneSpec.resetDate = function () {\n                if (global['Date'] === FakeDate) {\n                    global['Date'] = OriginalDate;\n                }\n            };\n            FakeAsyncTestZoneSpec.checkTimerPatch = function () {\n                if (global.setTimeout !== timers.setTimeout) {\n                    global.setTimeout = timers.setTimeout;\n                    global.clearTimeout = timers.clearTimeout;\n                }\n                if (global.setInterval !== timers.setInterval) {\n                    global.setInterval = timers.setInterval;\n                    global.clearInterval = timers.clearInterval;\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.lockDatePatch = function () {\n                this.patchDateLocked = true;\n                FakeAsyncTestZoneSpec.patchDate();\n            };\n            FakeAsyncTestZoneSpec.prototype.unlockDatePatch = function () {\n                this.patchDateLocked = false;\n                FakeAsyncTestZoneSpec.resetDate();\n            };\n            FakeAsyncTestZoneSpec.prototype.tick = function (millis, doTick, tickOptions) {\n                if (millis === void 0) { millis = 0; }\n                if (tickOptions === void 0) { tickOptions = { processNewMacroTasksSynchronously: true }; }\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                this._scheduler.tick(millis, doTick, tickOptions);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.flushMicrotasks = function () {\n                var _this = this;\n                FakeAsyncTestZoneSpec.assertInZone();\n                var flushErrors = function () {\n                    if (_this._lastError !== null || _this._uncaughtPromiseErrors.length) {\n                        // If there is an error stop processing the microtask queue and rethrow the error.\n                        _this._resetLastErrorAndThrow();\n                    }\n                };\n                while (this._microtasks.length > 0) {\n                    var microtask = this._microtasks.shift();\n                    microtask.func.apply(microtask.target, microtask.args);\n                }\n                flushErrors();\n            };\n            FakeAsyncTestZoneSpec.prototype.flush = function (limit, flushPeriodic, doTick) {\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                var elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n                return elapsed;\n            };\n            FakeAsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n                switch (task.type) {\n                    case 'microTask':\n                        var args = task.data && task.data.args;\n                        // should pass additional arguments to callback if have any\n                        // currently we know process.nextTick will have such additional\n                        // arguments\n                        var additionalArgs = void 0;\n                        if (args) {\n                            var callbackIndex = task.data.cbIdx;\n                            if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n                                additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n                            }\n                        }\n                        this._microtasks.push({\n                            func: task.invoke,\n                            args: additionalArgs,\n                            target: task.data && task.data.target\n                        });\n                        break;\n                    case 'macroTask':\n                        switch (task.source) {\n                            case 'setTimeout':\n                                task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                                break;\n                            case 'setImmediate':\n                                task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n                                break;\n                            case 'setInterval':\n                                task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                                break;\n                            case 'XMLHttpRequest.send':\n                                throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' +\n                                    task.data['url']);\n                            case 'requestAnimationFrame':\n                            case 'webkitRequestAnimationFrame':\n                            case 'mozRequestAnimationFrame':\n                                // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n                                // (60 frames per second)\n                                task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n                                break;\n                            default:\n                                // user can define which macroTask they want to support by passing\n                                // macroTaskOptions\n                                var macroTaskOption = this.findMacroTaskOption(task);\n                                if (macroTaskOption) {\n                                    var args_1 = task.data && task.data['args'];\n                                    var delay = args_1 && args_1.length > 1 ? args_1[1] : 0;\n                                    var callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args_1;\n                                    if (!!macroTaskOption.isPeriodic) {\n                                        // periodic macroTask, use setInterval to simulate\n                                        task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                                        task.data.isPeriodic = true;\n                                    }\n                                    else {\n                                        // not periodic, use setTimeout to simulate\n                                        task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                                    }\n                                    break;\n                                }\n                                throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n                        }\n                        break;\n                    case 'eventTask':\n                        task = delegate.scheduleTask(target, task);\n                        break;\n                }\n                return task;\n            };\n            FakeAsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n                switch (task.source) {\n                    case 'setTimeout':\n                    case 'requestAnimationFrame':\n                    case 'webkitRequestAnimationFrame':\n                    case 'mozRequestAnimationFrame':\n                        return this._clearTimeout(task.data['handleId']);\n                    case 'setInterval':\n                        return this._clearInterval(task.data['handleId']);\n                    default:\n                        // user can define which macroTask they want to support by passing\n                        // macroTaskOptions\n                        var macroTaskOption = this.findMacroTaskOption(task);\n                        if (macroTaskOption) {\n                            var handleId = task.data['handleId'];\n                            return macroTaskOption.isPeriodic ? this._clearInterval(handleId) :\n                                this._clearTimeout(handleId);\n                        }\n                        return delegate.cancelTask(target, task);\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.onInvoke = function (delegate, current, target, callback, applyThis, applyArgs, source) {\n                try {\n                    FakeAsyncTestZoneSpec.patchDate();\n                    return delegate.invoke(target, callback, applyThis, applyArgs, source);\n                }\n                finally {\n                    if (!this.patchDateLocked) {\n                        FakeAsyncTestZoneSpec.resetDate();\n                    }\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.findMacroTaskOption = function (task) {\n                if (!this.macroTaskOptions) {\n                    return null;\n                }\n                for (var i = 0; i < this.macroTaskOptions.length; i++) {\n                    var macroTaskOption = this.macroTaskOptions[i];\n                    if (macroTaskOption.source === task.source) {\n                        return macroTaskOption;\n                    }\n                }\n                return null;\n            };\n            FakeAsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n                this._lastError = error;\n                return false; // Don't propagate error to parent zone.\n            };\n            return FakeAsyncTestZoneSpec;\n        }());\n        // Export the class so that new instances can be created with proper\n        // constructor params.\n        Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n    })(typeof window === 'object' && window || typeof self === 'object' && self || global);\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    Zone.__load_patch('fakeasync', function (global, Zone, api) {\n        var FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n        var ProxyZoneSpec = Zone && Zone['ProxyZoneSpec'];\n        var _fakeAsyncTestZoneSpec = null;\n        /**\n         * Clears out the shared fake async zone for a test.\n         * To be called in a global `beforeEach`.\n         *\n         * @experimental\n         */\n        function resetFakeAsyncZone() {\n            if (_fakeAsyncTestZoneSpec) {\n                _fakeAsyncTestZoneSpec.unlockDatePatch();\n            }\n            _fakeAsyncTestZoneSpec = null;\n            // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n            ProxyZoneSpec && ProxyZoneSpec.assertPresent().resetDelegate();\n        }\n        /**\n         * Wraps a function to be executed in the fakeAsync zone:\n         * - microtasks are manually executed by calling `flushMicrotasks()`,\n         * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n         *\n         * If there are any pending timers at the end of the function, an exception will be thrown.\n         *\n         * Can be used to wrap inject() calls.\n         *\n         * ## Example\n         *\n         * {@example core/testing/ts/fake_async.ts region='basic'}\n         *\n         * @param fn\n         * @returns The function wrapped to be executed in the fakeAsync zone\n         *\n         * @experimental\n         */\n        function fakeAsync(fn) {\n            // Not using an arrow function to preserve context passed from call site\n            return function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var proxyZoneSpec = ProxyZoneSpec.assertPresent();\n                if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n                    throw new Error('fakeAsync() calls can not be nested');\n                }\n                try {\n                    // in case jasmine.clock init a fakeAsyncTestZoneSpec\n                    if (!_fakeAsyncTestZoneSpec) {\n                        if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n                            throw new Error('fakeAsync() calls can not be nested');\n                        }\n                        _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n                    }\n                    var res = void 0;\n                    var lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n                    proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n                    _fakeAsyncTestZoneSpec.lockDatePatch();\n                    try {\n                        res = fn.apply(this, args);\n                        flushMicrotasks();\n                    }\n                    finally {\n                        proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n                    }\n                    if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n                        throw new Error(_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length + \" \" +\n                            \"periodic timer(s) still in the queue.\");\n                    }\n                    if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n                        throw new Error(_fakeAsyncTestZoneSpec.pendingTimers.length + \" timer(s) still in the queue.\");\n                    }\n                    return res;\n                }\n                finally {\n                    resetFakeAsyncZone();\n                }\n            };\n        }\n        function _getFakeAsyncZoneSpec() {\n            if (_fakeAsyncTestZoneSpec == null) {\n                _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (_fakeAsyncTestZoneSpec == null) {\n                    throw new Error('The code should be running in the fakeAsync zone to call this function');\n                }\n            }\n            return _fakeAsyncTestZoneSpec;\n        }\n        /**\n         * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n         *\n         * The microtasks queue is drained at the very start of this function and after any timer callback\n         * has been executed.\n         *\n         * ## Example\n         *\n         * {@example core/testing/ts/fake_async.ts region='basic'}\n         *\n         * @experimental\n         */\n        function tick(millis, ignoreNestedTimeout) {\n            if (millis === void 0) { millis = 0; }\n            if (ignoreNestedTimeout === void 0) { ignoreNestedTimeout = false; }\n            _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n        }\n        /**\n         * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n         * draining the macrotask queue until it is empty. The returned value is the milliseconds\n         * of time that would have been elapsed.\n         *\n         * @param maxTurns\n         * @returns The simulated time elapsed, in millis.\n         *\n         * @experimental\n         */\n        function flush(maxTurns) { return _getFakeAsyncZoneSpec().flush(maxTurns); }\n        /**\n         * Discard all remaining periodic tasks.\n         *\n         * @experimental\n         */\n        function discardPeriodicTasks() {\n            var zoneSpec = _getFakeAsyncZoneSpec();\n            var pendingTimers = zoneSpec.pendingPeriodicTimers;\n            zoneSpec.pendingPeriodicTimers.length = 0;\n        }\n        /**\n         * Flush any pending microtasks.\n         *\n         * @experimental\n         */\n        function flushMicrotasks() { _getFakeAsyncZoneSpec().flushMicrotasks(); }\n        Zone[api.symbol('fakeAsyncTest')] = {\n            resetFakeAsyncZone: resetFakeAsyncZone, flushMicrotasks: flushMicrotasks, discardPeriodicTasks: discardPeriodicTasks, tick: tick, flush: flush, fakeAsync: fakeAsync\n        };\n    });\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Promise for async/fakeAsync zoneSpec test\n     * can support async operation which not supported by zone.js\n     * such as\n     * it ('test jsonp in AsyncZone', async() => {\n     *   new Promise(res => {\n     *     jsonp(url, (data) => {\n     *       // success callback\n     *       res(data);\n     *     });\n     *   }).then((jsonpResult) => {\n     *     // get jsonp result.\n     *\n     *     // user will expect AsyncZoneSpec wait for\n     *     // then, but because jsonp is not zone aware\n     *     // AsyncZone will finish before then is called.\n     *   });\n     * });\n     */\n    Zone.__load_patch('promisefortest', function (global, Zone, api) {\n        var symbolState = api.symbol('state');\n        var UNRESOLVED = null;\n        var symbolParentUnresolved = api.symbol('parentUnresolved');\n        // patch Promise.prototype.then to keep an internal\n        // number for tracking unresolved chained promise\n        // we will decrease this number when the parent promise\n        // being resolved/rejected and chained promise was\n        // scheduled as a microTask.\n        // so we can know such kind of chained promise still\n        // not resolved in AsyncTestZone\n        Promise[api.symbol('patchPromiseForTest')] = function patchPromiseForTest() {\n            var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n            if (oriThen) {\n                return;\n            }\n            oriThen = Promise[Zone.__symbol__('ZonePromiseThen')] = Promise.prototype.then;\n            Promise.prototype.then = function () {\n                var chained = oriThen.apply(this, arguments);\n                if (this[symbolState] === UNRESOLVED) {\n                    // parent promise is unresolved.\n                    var asyncTestZoneSpec = Zone.current.get('AsyncTestZoneSpec');\n                    if (asyncTestZoneSpec) {\n                        asyncTestZoneSpec.unresolvedChainedPromiseCount++;\n                        chained[symbolParentUnresolved] = true;\n                    }\n                }\n                return chained;\n            };\n        };\n        Promise[api.symbol('unPatchPromiseForTest')] = function unpatchPromiseForTest() {\n            // restore origin then\n            var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n            if (oriThen) {\n                Promise.prototype.then = oriThen;\n                Promise[Zone.__symbol__('ZonePromiseThen')] = undefined;\n            }\n        };\n    });\n})));\n"
    ]
  },
  "metadata": {},
  "sourceType": "script"
}
